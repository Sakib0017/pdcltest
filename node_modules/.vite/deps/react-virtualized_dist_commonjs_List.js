import {
  require_assertThisInitialized,
  require_classCallCheck,
  require_createClass,
  require_defineProperty,
  require_getPrototypeOf,
  require_inherits,
  require_interopRequireDefault,
  require_interopRequireWildcard,
  require_possibleConstructorReturn
} from "./chunk-5W3432MO.js";
import {
  require_prop_types
} from "./chunk-63ILDAJJ.js";
import {
  require_react
} from "./chunk-EFTEWGEA.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-V4OQ3NZ2.js";

// node_modules/@babel/runtime/helpers/extends.js
var require_extends = __commonJS({
  "node_modules/@babel/runtime/helpers/extends.js"(exports, module) {
    function _extends() {
      module.exports = _extends = Object.assign ? Object.assign.bind() : function(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];
          for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }
        return target;
      }, module.exports.__esModule = true, module.exports["default"] = module.exports;
      return _extends.apply(this, arguments);
    }
    module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/clsx/dist/clsx.m.js
var clsx_m_exports = {};
__export(clsx_m_exports, {
  clsx: () => clsx,
  default: () => clsx_m_default
});
function r(e) {
  var t, f, n = "";
  if ("string" == typeof e || "number" == typeof e) n += e;
  else if ("object" == typeof e) if (Array.isArray(e)) for (t = 0; t < e.length; t++) e[t] && (f = r(e[t])) && (n && (n += " "), n += f);
  else for (t in e) e[t] && (n && (n += " "), n += t);
  return n;
}
function clsx() {
  for (var e, t, f = 0, n = ""; f < arguments.length; ) (e = arguments[f++]) && (t = r(e)) && (n && (n += " "), n += t);
  return n;
}
var clsx_m_default;
var init_clsx_m = __esm({
  "node_modules/clsx/dist/clsx.m.js"() {
    clsx_m_default = clsx;
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js
var require_calculateSizeAndPositionDataAndUpdateScrollOffset = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/utils/calculateSizeAndPositionDataAndUpdateScrollOffset.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = calculateSizeAndPositionDataAndUpdateScrollOffset;
    function calculateSizeAndPositionDataAndUpdateScrollOffset(_ref) {
      var cellCount = _ref.cellCount, cellSize = _ref.cellSize, computeMetadataCallback = _ref.computeMetadataCallback, computeMetadataCallbackProps = _ref.computeMetadataCallbackProps, nextCellsCount = _ref.nextCellsCount, nextCellSize = _ref.nextCellSize, nextScrollToIndex = _ref.nextScrollToIndex, scrollToIndex = _ref.scrollToIndex, updateScrollOffsetForScrollToIndex = _ref.updateScrollOffsetForScrollToIndex;
      if (cellCount !== nextCellsCount || (typeof cellSize === "number" || typeof nextCellSize === "number") && cellSize !== nextCellSize) {
        computeMetadataCallback(computeMetadataCallbackProps);
        if (scrollToIndex >= 0 && scrollToIndex === nextScrollToIndex) {
          updateScrollOffsetForScrollToIndex();
        }
      }
    }
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js
var require_objectWithoutPropertiesLoose = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js"(exports, module) {
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/@babel/runtime/helpers/objectWithoutProperties.js
var require_objectWithoutProperties = __commonJS({
  "node_modules/@babel/runtime/helpers/objectWithoutProperties.js"(exports, module) {
    var objectWithoutPropertiesLoose = require_objectWithoutPropertiesLoose();
    function _objectWithoutProperties(source, excluded) {
      if (source == null) return {};
      var target = objectWithoutPropertiesLoose(source, excluded);
      var key, i;
      if (Object.getOwnPropertySymbols) {
        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);
        for (i = 0; i < sourceSymbolKeys.length; i++) {
          key = sourceSymbolKeys[i];
          if (excluded.indexOf(key) >= 0) continue;
          if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
          target[key] = source[key];
        }
      }
      return target;
    }
    module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/types.js
var require_types = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/types.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bpfrpt_proptype_VisibleCellRange = exports.bpfrpt_proptype_Alignment = exports.bpfrpt_proptype_OverscanIndicesGetter = exports.bpfrpt_proptype_OverscanIndices = exports.bpfrpt_proptype_OverscanIndicesGetterParams = exports.bpfrpt_proptype_RenderedSection = exports.bpfrpt_proptype_ScrollbarPresenceChange = exports.bpfrpt_proptype_Scroll = exports.bpfrpt_proptype_NoContentRenderer = exports.bpfrpt_proptype_CellSize = exports.bpfrpt_proptype_CellSizeGetter = exports.bpfrpt_proptype_CellRangeRenderer = exports.bpfrpt_proptype_CellRangeRendererParams = exports.bpfrpt_proptype_StyleCache = exports.bpfrpt_proptype_CellCache = exports.bpfrpt_proptype_CellRenderer = exports.bpfrpt_proptype_CellRendererParams = exports.bpfrpt_proptype_CellPosition = void 0;
    var React = _interopRequireWildcard(require_react());
    var _ScalingCellSizeAndPositionManager = _interopRequireDefault(require_ScalingCellSizeAndPositionManager());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var bpfrpt_proptype_CellPosition = false ? null : {
      "columnIndex": _propTypes["default"].number.isRequired,
      "rowIndex": _propTypes["default"].number.isRequired
    };
    exports.bpfrpt_proptype_CellPosition = bpfrpt_proptype_CellPosition;
    var bpfrpt_proptype_CellRendererParams = false ? null : {
      "columnIndex": _propTypes["default"].number.isRequired,
      "isScrolling": _propTypes["default"].bool.isRequired,
      "isVisible": _propTypes["default"].bool.isRequired,
      "key": _propTypes["default"].string.isRequired,
      "parent": _propTypes["default"].object.isRequired,
      "rowIndex": _propTypes["default"].number.isRequired,
      "style": _propTypes["default"].object.isRequired
    };
    exports.bpfrpt_proptype_CellRendererParams = bpfrpt_proptype_CellRendererParams;
    var bpfrpt_proptype_CellRenderer = false ? null : _propTypes["default"].func;
    exports.bpfrpt_proptype_CellRenderer = bpfrpt_proptype_CellRenderer;
    var bpfrpt_proptype_CellCache = false ? null : _propTypes["default"].objectOf(_propTypes["default"].node.isRequired);
    exports.bpfrpt_proptype_CellCache = bpfrpt_proptype_CellCache;
    var bpfrpt_proptype_StyleCache = false ? null : _propTypes["default"].objectOf(_propTypes["default"].object.isRequired);
    exports.bpfrpt_proptype_StyleCache = bpfrpt_proptype_StyleCache;
    var bpfrpt_proptype_CellRangeRendererParams = false ? null : {
      "cellCache": _propTypes["default"].objectOf(_propTypes["default"].node.isRequired).isRequired,
      "cellRenderer": _propTypes["default"].func.isRequired,
      "columnSizeAndPositionManager": function columnSizeAndPositionManager() {
        return (typeof _ScalingCellSizeAndPositionManager["default"] === "function" ? _propTypes["default"].instanceOf(_ScalingCellSizeAndPositionManager["default"]).isRequired : _propTypes["default"].any.isRequired).apply(this, arguments);
      },
      "columnStartIndex": _propTypes["default"].number.isRequired,
      "columnStopIndex": _propTypes["default"].number.isRequired,
      "deferredMeasurementCache": _propTypes["default"].object,
      "horizontalOffsetAdjustment": _propTypes["default"].number.isRequired,
      "isScrolling": _propTypes["default"].bool.isRequired,
      "isScrollingOptOut": _propTypes["default"].bool.isRequired,
      "parent": _propTypes["default"].object.isRequired,
      "rowSizeAndPositionManager": function rowSizeAndPositionManager() {
        return (typeof _ScalingCellSizeAndPositionManager["default"] === "function" ? _propTypes["default"].instanceOf(_ScalingCellSizeAndPositionManager["default"]).isRequired : _propTypes["default"].any.isRequired).apply(this, arguments);
      },
      "rowStartIndex": _propTypes["default"].number.isRequired,
      "rowStopIndex": _propTypes["default"].number.isRequired,
      "scrollLeft": _propTypes["default"].number.isRequired,
      "scrollTop": _propTypes["default"].number.isRequired,
      "styleCache": _propTypes["default"].objectOf(_propTypes["default"].object.isRequired).isRequired,
      "verticalOffsetAdjustment": _propTypes["default"].number.isRequired,
      "visibleColumnIndices": _propTypes["default"].object.isRequired,
      "visibleRowIndices": _propTypes["default"].object.isRequired
    };
    exports.bpfrpt_proptype_CellRangeRendererParams = bpfrpt_proptype_CellRangeRendererParams;
    var bpfrpt_proptype_CellRangeRenderer = false ? null : _propTypes["default"].func;
    exports.bpfrpt_proptype_CellRangeRenderer = bpfrpt_proptype_CellRangeRenderer;
    var bpfrpt_proptype_CellSizeGetter = false ? null : _propTypes["default"].func;
    exports.bpfrpt_proptype_CellSizeGetter = bpfrpt_proptype_CellSizeGetter;
    var bpfrpt_proptype_CellSize = false ? null : _propTypes["default"].oneOfType([_propTypes["default"].func, _propTypes["default"].number]);
    exports.bpfrpt_proptype_CellSize = bpfrpt_proptype_CellSize;
    var bpfrpt_proptype_NoContentRenderer = false ? null : _propTypes["default"].func;
    exports.bpfrpt_proptype_NoContentRenderer = bpfrpt_proptype_NoContentRenderer;
    var bpfrpt_proptype_Scroll = false ? null : {
      "clientHeight": _propTypes["default"].number.isRequired,
      "clientWidth": _propTypes["default"].number.isRequired,
      "scrollHeight": _propTypes["default"].number.isRequired,
      "scrollLeft": _propTypes["default"].number.isRequired,
      "scrollTop": _propTypes["default"].number.isRequired,
      "scrollWidth": _propTypes["default"].number.isRequired
    };
    exports.bpfrpt_proptype_Scroll = bpfrpt_proptype_Scroll;
    var bpfrpt_proptype_ScrollbarPresenceChange = false ? null : {
      "horizontal": _propTypes["default"].bool.isRequired,
      "vertical": _propTypes["default"].bool.isRequired,
      "size": _propTypes["default"].number.isRequired
    };
    exports.bpfrpt_proptype_ScrollbarPresenceChange = bpfrpt_proptype_ScrollbarPresenceChange;
    var bpfrpt_proptype_RenderedSection = false ? null : {
      "columnOverscanStartIndex": _propTypes["default"].number.isRequired,
      "columnOverscanStopIndex": _propTypes["default"].number.isRequired,
      "columnStartIndex": _propTypes["default"].number.isRequired,
      "columnStopIndex": _propTypes["default"].number.isRequired,
      "rowOverscanStartIndex": _propTypes["default"].number.isRequired,
      "rowOverscanStopIndex": _propTypes["default"].number.isRequired,
      "rowStartIndex": _propTypes["default"].number.isRequired,
      "rowStopIndex": _propTypes["default"].number.isRequired
    };
    exports.bpfrpt_proptype_RenderedSection = bpfrpt_proptype_RenderedSection;
    var bpfrpt_proptype_OverscanIndicesGetterParams = false ? null : {
      // One of SCROLL_DIRECTION_HORIZONTAL or SCROLL_DIRECTION_VERTICAL
      "direction": _propTypes["default"].oneOf(["horizontal", "vertical"]).isRequired,
      // One of SCROLL_DIRECTION_BACKWARD or SCROLL_DIRECTION_FORWARD
      "scrollDirection": _propTypes["default"].oneOf([-1, 1]).isRequired,
      // Number of rows or columns in the current axis
      "cellCount": _propTypes["default"].number.isRequired,
      // Maximum number of cells to over-render in either direction
      "overscanCellsCount": _propTypes["default"].number.isRequired,
      // Begin of range of visible cells
      "startIndex": _propTypes["default"].number.isRequired,
      // End of range of visible cells
      "stopIndex": _propTypes["default"].number.isRequired
    };
    exports.bpfrpt_proptype_OverscanIndicesGetterParams = bpfrpt_proptype_OverscanIndicesGetterParams;
    var bpfrpt_proptype_OverscanIndices = false ? null : {
      "overscanStartIndex": _propTypes["default"].number.isRequired,
      "overscanStopIndex": _propTypes["default"].number.isRequired
    };
    exports.bpfrpt_proptype_OverscanIndices = bpfrpt_proptype_OverscanIndices;
    var bpfrpt_proptype_OverscanIndicesGetter = false ? null : _propTypes["default"].func;
    exports.bpfrpt_proptype_OverscanIndicesGetter = bpfrpt_proptype_OverscanIndicesGetter;
    var bpfrpt_proptype_Alignment = false ? null : _propTypes["default"].oneOf(["auto", "end", "start", "center"]);
    exports.bpfrpt_proptype_Alignment = bpfrpt_proptype_Alignment;
    var bpfrpt_proptype_VisibleCellRange = false ? null : {
      "start": _propTypes["default"].number,
      "stop": _propTypes["default"].number
    };
    exports.bpfrpt_proptype_VisibleCellRange = bpfrpt_proptype_VisibleCellRange;
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/utils/CellSizeAndPositionManager.js
var require_CellSizeAndPositionManager = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/utils/CellSizeAndPositionManager.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _types = require_types();
    var CellSizeAndPositionManager = function() {
      function CellSizeAndPositionManager2(_ref) {
        var cellCount = _ref.cellCount, cellSizeGetter = _ref.cellSizeGetter, estimatedCellSize = _ref.estimatedCellSize;
        (0, _classCallCheck2["default"])(this, CellSizeAndPositionManager2);
        (0, _defineProperty2["default"])(this, "_cellSizeAndPositionData", {});
        (0, _defineProperty2["default"])(this, "_lastMeasuredIndex", -1);
        (0, _defineProperty2["default"])(this, "_lastBatchedIndex", -1);
        (0, _defineProperty2["default"])(this, "_cellCount", void 0);
        (0, _defineProperty2["default"])(this, "_cellSizeGetter", void 0);
        (0, _defineProperty2["default"])(this, "_estimatedCellSize", void 0);
        this._cellSizeGetter = cellSizeGetter;
        this._cellCount = cellCount;
        this._estimatedCellSize = estimatedCellSize;
      }
      (0, _createClass2["default"])(CellSizeAndPositionManager2, [{
        key: "areOffsetsAdjusted",
        value: function areOffsetsAdjusted() {
          return false;
        }
      }, {
        key: "configure",
        value: function configure(_ref2) {
          var cellCount = _ref2.cellCount, estimatedCellSize = _ref2.estimatedCellSize, cellSizeGetter = _ref2.cellSizeGetter;
          this._cellCount = cellCount;
          this._estimatedCellSize = estimatedCellSize;
          this._cellSizeGetter = cellSizeGetter;
        }
      }, {
        key: "getCellCount",
        value: function getCellCount() {
          return this._cellCount;
        }
      }, {
        key: "getEstimatedCellSize",
        value: function getEstimatedCellSize() {
          return this._estimatedCellSize;
        }
      }, {
        key: "getLastMeasuredIndex",
        value: function getLastMeasuredIndex() {
          return this._lastMeasuredIndex;
        }
      }, {
        key: "getOffsetAdjustment",
        value: function getOffsetAdjustment() {
          return 0;
        }
        /**
         * This method returns the size and position for the cell at the specified index.
         * It just-in-time calculates (or used cached values) for cells leading up to the index.
         */
      }, {
        key: "getSizeAndPositionOfCell",
        value: function getSizeAndPositionOfCell(index) {
          if (index < 0 || index >= this._cellCount) {
            throw Error("Requested index ".concat(index, " is outside of range 0..").concat(this._cellCount));
          }
          if (index > this._lastMeasuredIndex) {
            var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
            var offset = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;
            for (var i = this._lastMeasuredIndex + 1; i <= index; i++) {
              var size2 = this._cellSizeGetter({
                index: i
              });
              if (size2 === void 0 || isNaN(size2)) {
                throw Error("Invalid size returned for cell ".concat(i, " of value ").concat(size2));
              } else if (size2 === null) {
                this._cellSizeAndPositionData[i] = {
                  offset,
                  size: 0
                };
                this._lastBatchedIndex = index;
              } else {
                this._cellSizeAndPositionData[i] = {
                  offset,
                  size: size2
                };
                offset += size2;
                this._lastMeasuredIndex = index;
              }
            }
          }
          return this._cellSizeAndPositionData[index];
        }
      }, {
        key: "getSizeAndPositionOfLastMeasuredCell",
        value: function getSizeAndPositionOfLastMeasuredCell() {
          return this._lastMeasuredIndex >= 0 ? this._cellSizeAndPositionData[this._lastMeasuredIndex] : {
            offset: 0,
            size: 0
          };
        }
        /**
         * Total size of all cells being measured.
         * This value will be completely estimated initially.
         * As cells are measured, the estimate will be updated.
         */
      }, {
        key: "getTotalSize",
        value: function getTotalSize() {
          var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
          var totalSizeOfMeasuredCells = lastMeasuredCellSizeAndPosition.offset + lastMeasuredCellSizeAndPosition.size;
          var numUnmeasuredCells = this._cellCount - this._lastMeasuredIndex - 1;
          var totalSizeOfUnmeasuredCells = numUnmeasuredCells * this._estimatedCellSize;
          return totalSizeOfMeasuredCells + totalSizeOfUnmeasuredCells;
        }
        /**
         * Determines a new offset that ensures a certain cell is visible, given the current offset.
         * If the cell is already visible then the current offset will be returned.
         * If the current offset is too great or small, it will be adjusted just enough to ensure the specified index is visible.
         *
         * @param align Desired alignment within container; one of "auto" (default), "start", or "end"
         * @param containerSize Size (width or height) of the container viewport
         * @param currentOffset Container's current (x or y) offset
         * @param totalSize Total size (width or height) of all cells
         * @return Offset to use to ensure the specified cell is visible
         */
      }, {
        key: "getUpdatedOffsetForIndex",
        value: function getUpdatedOffsetForIndex(_ref3) {
          var _ref3$align = _ref3.align, align = _ref3$align === void 0 ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
          if (containerSize <= 0) {
            return 0;
          }
          var datum = this.getSizeAndPositionOfCell(targetIndex);
          var maxOffset = datum.offset;
          var minOffset = maxOffset - containerSize + datum.size;
          var idealOffset;
          switch (align) {
            case "start":
              idealOffset = maxOffset;
              break;
            case "end":
              idealOffset = minOffset;
              break;
            case "center":
              idealOffset = maxOffset - (containerSize - datum.size) / 2;
              break;
            default:
              idealOffset = Math.max(minOffset, Math.min(maxOffset, currentOffset));
              break;
          }
          var totalSize = this.getTotalSize();
          return Math.max(0, Math.min(totalSize - containerSize, idealOffset));
        }
      }, {
        key: "getVisibleCellRange",
        value: function getVisibleCellRange(params) {
          var containerSize = params.containerSize, offset = params.offset;
          var totalSize = this.getTotalSize();
          if (totalSize === 0) {
            return {};
          }
          var maxOffset = offset + containerSize;
          var start = this._findNearestCell(offset);
          var datum = this.getSizeAndPositionOfCell(start);
          offset = datum.offset + datum.size;
          var stop = start;
          while (offset < maxOffset && stop < this._cellCount - 1) {
            stop++;
            offset += this.getSizeAndPositionOfCell(stop).size;
          }
          return {
            start,
            stop
          };
        }
        /**
         * Clear all cached values for cells after the specified index.
         * This method should be called for any cell that has changed its size.
         * It will not immediately perform any calculations; they'll be performed the next time getSizeAndPositionOfCell() is called.
         */
      }, {
        key: "resetCell",
        value: function resetCell(index) {
          this._lastMeasuredIndex = Math.min(this._lastMeasuredIndex, index - 1);
        }
      }, {
        key: "_binarySearch",
        value: function _binarySearch(high, low, offset) {
          while (low <= high) {
            var middle = low + Math.floor((high - low) / 2);
            var currentOffset = this.getSizeAndPositionOfCell(middle).offset;
            if (currentOffset === offset) {
              return middle;
            } else if (currentOffset < offset) {
              low = middle + 1;
            } else if (currentOffset > offset) {
              high = middle - 1;
            }
          }
          if (low > 0) {
            return low - 1;
          } else {
            return 0;
          }
        }
      }, {
        key: "_exponentialSearch",
        value: function _exponentialSearch(index, offset) {
          var interval = 1;
          while (index < this._cellCount && this.getSizeAndPositionOfCell(index).offset < offset) {
            index += interval;
            interval *= 2;
          }
          return this._binarySearch(Math.min(index, this._cellCount - 1), Math.floor(index / 2), offset);
        }
        /**
         * Searches for the cell (index) nearest the specified offset.
         *
         * If no exact match is found the next lowest cell index will be returned.
         * This allows partially visible cells (with offsets just before/above the fold) to be visible.
         */
      }, {
        key: "_findNearestCell",
        value: function _findNearestCell(offset) {
          if (isNaN(offset)) {
            throw Error("Invalid offset ".concat(offset, " specified"));
          }
          offset = Math.max(0, offset);
          var lastMeasuredCellSizeAndPosition = this.getSizeAndPositionOfLastMeasuredCell();
          var lastMeasuredIndex = Math.max(0, this._lastMeasuredIndex);
          if (lastMeasuredCellSizeAndPosition.offset >= offset) {
            return this._binarySearch(lastMeasuredIndex, 0, offset);
          } else {
            return this._exponentialSearch(lastMeasuredIndex, offset);
          }
        }
      }]);
      return CellSizeAndPositionManager2;
    }();
    exports["default"] = CellSizeAndPositionManager;
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/utils/maxElementSize.js
var require_maxElementSize = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/utils/maxElementSize.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.getMaxElementSize = void 0;
    var DEFAULT_MAX_ELEMENT_SIZE = 15e5;
    var CHROME_MAX_ELEMENT_SIZE = 16777100;
    var isBrowser = function isBrowser2() {
      return typeof window !== "undefined";
    };
    var isChrome = function isChrome2() {
      return !!window.chrome;
    };
    var getMaxElementSize = function getMaxElementSize2() {
      if (isBrowser()) {
        if (isChrome()) {
          return CHROME_MAX_ELEMENT_SIZE;
        }
      }
      return DEFAULT_MAX_ELEMENT_SIZE;
    };
    exports.getMaxElementSize = getMaxElementSize;
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/utils/ScalingCellSizeAndPositionManager.js
var require_ScalingCellSizeAndPositionManager = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/utils/ScalingCellSizeAndPositionManager.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _objectWithoutProperties2 = _interopRequireDefault(require_objectWithoutProperties());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _CellSizeAndPositionManager = _interopRequireDefault(require_CellSizeAndPositionManager());
    var _maxElementSize = require_maxElementSize();
    var _types = require_types();
    var ScalingCellSizeAndPositionManager = function() {
      function ScalingCellSizeAndPositionManager2(_ref) {
        var _ref$maxScrollSize = _ref.maxScrollSize, maxScrollSize = _ref$maxScrollSize === void 0 ? (0, _maxElementSize.getMaxElementSize)() : _ref$maxScrollSize, params = (0, _objectWithoutProperties2["default"])(_ref, ["maxScrollSize"]);
        (0, _classCallCheck2["default"])(this, ScalingCellSizeAndPositionManager2);
        (0, _defineProperty2["default"])(this, "_cellSizeAndPositionManager", void 0);
        (0, _defineProperty2["default"])(this, "_maxScrollSize", void 0);
        this._cellSizeAndPositionManager = new _CellSizeAndPositionManager["default"](params);
        this._maxScrollSize = maxScrollSize;
      }
      (0, _createClass2["default"])(ScalingCellSizeAndPositionManager2, [{
        key: "areOffsetsAdjusted",
        value: function areOffsetsAdjusted() {
          return this._cellSizeAndPositionManager.getTotalSize() > this._maxScrollSize;
        }
      }, {
        key: "configure",
        value: function configure(params) {
          this._cellSizeAndPositionManager.configure(params);
        }
      }, {
        key: "getCellCount",
        value: function getCellCount() {
          return this._cellSizeAndPositionManager.getCellCount();
        }
      }, {
        key: "getEstimatedCellSize",
        value: function getEstimatedCellSize() {
          return this._cellSizeAndPositionManager.getEstimatedCellSize();
        }
      }, {
        key: "getLastMeasuredIndex",
        value: function getLastMeasuredIndex() {
          return this._cellSizeAndPositionManager.getLastMeasuredIndex();
        }
        /**
         * Number of pixels a cell at the given position (offset) should be shifted in order to fit within the scaled container.
         * The offset passed to this function is scaled (safe) as well.
         */
      }, {
        key: "getOffsetAdjustment",
        value: function getOffsetAdjustment(_ref2) {
          var containerSize = _ref2.containerSize, offset = _ref2.offset;
          var totalSize = this._cellSizeAndPositionManager.getTotalSize();
          var safeTotalSize = this.getTotalSize();
          var offsetPercentage = this._getOffsetPercentage({
            containerSize,
            offset,
            totalSize: safeTotalSize
          });
          return Math.round(offsetPercentage * (safeTotalSize - totalSize));
        }
      }, {
        key: "getSizeAndPositionOfCell",
        value: function getSizeAndPositionOfCell(index) {
          return this._cellSizeAndPositionManager.getSizeAndPositionOfCell(index);
        }
      }, {
        key: "getSizeAndPositionOfLastMeasuredCell",
        value: function getSizeAndPositionOfLastMeasuredCell() {
          return this._cellSizeAndPositionManager.getSizeAndPositionOfLastMeasuredCell();
        }
        /** See CellSizeAndPositionManager#getTotalSize */
      }, {
        key: "getTotalSize",
        value: function getTotalSize() {
          return Math.min(this._maxScrollSize, this._cellSizeAndPositionManager.getTotalSize());
        }
        /** See CellSizeAndPositionManager#getUpdatedOffsetForIndex */
      }, {
        key: "getUpdatedOffsetForIndex",
        value: function getUpdatedOffsetForIndex(_ref3) {
          var _ref3$align = _ref3.align, align = _ref3$align === void 0 ? "auto" : _ref3$align, containerSize = _ref3.containerSize, currentOffset = _ref3.currentOffset, targetIndex = _ref3.targetIndex;
          currentOffset = this._safeOffsetToOffset({
            containerSize,
            offset: currentOffset
          });
          var offset = this._cellSizeAndPositionManager.getUpdatedOffsetForIndex({
            align,
            containerSize,
            currentOffset,
            targetIndex
          });
          return this._offsetToSafeOffset({
            containerSize,
            offset
          });
        }
        /** See CellSizeAndPositionManager#getVisibleCellRange */
      }, {
        key: "getVisibleCellRange",
        value: function getVisibleCellRange(_ref4) {
          var containerSize = _ref4.containerSize, offset = _ref4.offset;
          offset = this._safeOffsetToOffset({
            containerSize,
            offset
          });
          return this._cellSizeAndPositionManager.getVisibleCellRange({
            containerSize,
            offset
          });
        }
      }, {
        key: "resetCell",
        value: function resetCell(index) {
          this._cellSizeAndPositionManager.resetCell(index);
        }
      }, {
        key: "_getOffsetPercentage",
        value: function _getOffsetPercentage(_ref5) {
          var containerSize = _ref5.containerSize, offset = _ref5.offset, totalSize = _ref5.totalSize;
          return totalSize <= containerSize ? 0 : offset / (totalSize - containerSize);
        }
      }, {
        key: "_offsetToSafeOffset",
        value: function _offsetToSafeOffset(_ref6) {
          var containerSize = _ref6.containerSize, offset = _ref6.offset;
          var totalSize = this._cellSizeAndPositionManager.getTotalSize();
          var safeTotalSize = this.getTotalSize();
          if (totalSize === safeTotalSize) {
            return offset;
          } else {
            var offsetPercentage = this._getOffsetPercentage({
              containerSize,
              offset,
              totalSize
            });
            return Math.round(offsetPercentage * (safeTotalSize - containerSize));
          }
        }
      }, {
        key: "_safeOffsetToOffset",
        value: function _safeOffsetToOffset(_ref7) {
          var containerSize = _ref7.containerSize, offset = _ref7.offset;
          var totalSize = this._cellSizeAndPositionManager.getTotalSize();
          var safeTotalSize = this.getTotalSize();
          if (totalSize === safeTotalSize) {
            return offset;
          } else {
            var offsetPercentage = this._getOffsetPercentage({
              containerSize,
              offset,
              totalSize: safeTotalSize
            });
            return Math.round(offsetPercentage * (totalSize - containerSize));
          }
        }
      }]);
      return ScalingCellSizeAndPositionManager2;
    }();
    exports["default"] = ScalingCellSizeAndPositionManager;
  }
});

// node_modules/react-virtualized/dist/commonjs/utils/createCallbackMemoizer.js
var require_createCallbackMemoizer = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/utils/createCallbackMemoizer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = createCallbackMemoizer;
    function createCallbackMemoizer() {
      var requireAllKeys = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;
      var cachedIndices = {};
      return function(_ref) {
        var callback = _ref.callback, indices = _ref.indices;
        var keys = Object.keys(indices);
        var allInitialized = !requireAllKeys || keys.every(function(key) {
          var value = indices[key];
          return Array.isArray(value) ? value.length > 0 : value >= 0;
        });
        var indexChanged = keys.length !== Object.keys(cachedIndices).length || keys.some(function(key) {
          var cachedValue = cachedIndices[key];
          var value = indices[key];
          return Array.isArray(value) ? cachedValue.join(",") !== value.join(",") : cachedValue !== value;
        });
        cachedIndices = indices;
        if (allInitialized && indexChanged) {
          callback(indices);
        }
      };
    }
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/defaultOverscanIndicesGetter.js
var require_defaultOverscanIndicesGetter = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/defaultOverscanIndicesGetter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = defaultOverscanIndicesGetter;
    exports.SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_BACKWARD = void 0;
    var _types = require_types();
    var SCROLL_DIRECTION_BACKWARD = -1;
    exports.SCROLL_DIRECTION_BACKWARD = SCROLL_DIRECTION_BACKWARD;
    var SCROLL_DIRECTION_FORWARD = 1;
    exports.SCROLL_DIRECTION_FORWARD = SCROLL_DIRECTION_FORWARD;
    var SCROLL_DIRECTION_HORIZONTAL = "horizontal";
    exports.SCROLL_DIRECTION_HORIZONTAL = SCROLL_DIRECTION_HORIZONTAL;
    var SCROLL_DIRECTION_VERTICAL = "vertical";
    exports.SCROLL_DIRECTION_VERTICAL = SCROLL_DIRECTION_VERTICAL;
    function defaultOverscanIndicesGetter(_ref) {
      var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
      if (scrollDirection === SCROLL_DIRECTION_FORWARD) {
        return {
          overscanStartIndex: Math.max(0, startIndex),
          overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
        };
      } else {
        return {
          overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
          overscanStopIndex: Math.min(cellCount - 1, stopIndex)
        };
      }
    }
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/utils/updateScrollIndexHelper.js
var require_updateScrollIndexHelper = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/utils/updateScrollIndexHelper.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = updateScrollIndexHelper;
    var _ScalingCellSizeAndPositionManager = _interopRequireDefault(require_ScalingCellSizeAndPositionManager());
    var _types = require_types();
    function updateScrollIndexHelper(_ref) {
      var cellSize = _ref.cellSize, cellSizeAndPositionManager = _ref.cellSizeAndPositionManager, previousCellsCount = _ref.previousCellsCount, previousCellSize = _ref.previousCellSize, previousScrollToAlignment = _ref.previousScrollToAlignment, previousScrollToIndex = _ref.previousScrollToIndex, previousSize = _ref.previousSize, scrollOffset = _ref.scrollOffset, scrollToAlignment = _ref.scrollToAlignment, scrollToIndex = _ref.scrollToIndex, size2 = _ref.size, sizeJustIncreasedFromZero = _ref.sizeJustIncreasedFromZero, updateScrollIndexCallback = _ref.updateScrollIndexCallback;
      var cellCount = cellSizeAndPositionManager.getCellCount();
      var hasScrollToIndex = scrollToIndex >= 0 && scrollToIndex < cellCount;
      var sizeHasChanged = size2 !== previousSize || sizeJustIncreasedFromZero || !previousCellSize || typeof cellSize === "number" && cellSize !== previousCellSize;
      if (hasScrollToIndex && (sizeHasChanged || scrollToAlignment !== previousScrollToAlignment || scrollToIndex !== previousScrollToIndex)) {
        updateScrollIndexCallback(scrollToIndex);
      } else if (!hasScrollToIndex && cellCount > 0 && (size2 < previousSize || cellCount < previousCellsCount)) {
        if (scrollOffset > cellSizeAndPositionManager.getTotalSize() - size2) {
          updateScrollIndexCallback(cellCount - 1);
        }
      }
    }
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/defaultCellRangeRenderer.js
var require_defaultCellRangeRenderer = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/defaultCellRangeRenderer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = defaultCellRangeRenderer;
    var _types = require_types();
    function defaultCellRangeRenderer(_ref) {
      var cellCache = _ref.cellCache, cellRenderer = _ref.cellRenderer, columnSizeAndPositionManager = _ref.columnSizeAndPositionManager, columnStartIndex = _ref.columnStartIndex, columnStopIndex = _ref.columnStopIndex, deferredMeasurementCache = _ref.deferredMeasurementCache, horizontalOffsetAdjustment = _ref.horizontalOffsetAdjustment, isScrolling = _ref.isScrolling, isScrollingOptOut = _ref.isScrollingOptOut, parent = _ref.parent, rowSizeAndPositionManager = _ref.rowSizeAndPositionManager, rowStartIndex = _ref.rowStartIndex, rowStopIndex = _ref.rowStopIndex, styleCache = _ref.styleCache, verticalOffsetAdjustment = _ref.verticalOffsetAdjustment, visibleColumnIndices = _ref.visibleColumnIndices, visibleRowIndices = _ref.visibleRowIndices;
      var renderedCells = [];
      var areOffsetsAdjusted = columnSizeAndPositionManager.areOffsetsAdjusted() || rowSizeAndPositionManager.areOffsetsAdjusted();
      var canCacheStyle = !isScrolling && !areOffsetsAdjusted;
      for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {
        var rowDatum = rowSizeAndPositionManager.getSizeAndPositionOfCell(rowIndex);
        for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
          var columnDatum = columnSizeAndPositionManager.getSizeAndPositionOfCell(columnIndex);
          var isVisible = columnIndex >= visibleColumnIndices.start && columnIndex <= visibleColumnIndices.stop && rowIndex >= visibleRowIndices.start && rowIndex <= visibleRowIndices.stop;
          var key = "".concat(rowIndex, "-").concat(columnIndex);
          var style = void 0;
          if (canCacheStyle && styleCache[key]) {
            style = styleCache[key];
          } else {
            if (deferredMeasurementCache && !deferredMeasurementCache.has(rowIndex, columnIndex)) {
              style = {
                height: "auto",
                left: 0,
                position: "absolute",
                top: 0,
                width: "auto"
              };
            } else {
              style = {
                height: rowDatum.size,
                left: columnDatum.offset + horizontalOffsetAdjustment,
                position: "absolute",
                top: rowDatum.offset + verticalOffsetAdjustment,
                width: columnDatum.size
              };
              styleCache[key] = style;
            }
          }
          var cellRendererParams = {
            columnIndex,
            isScrolling,
            isVisible,
            key,
            parent,
            rowIndex,
            style
          };
          var renderedCell = void 0;
          if ((isScrollingOptOut || isScrolling) && !horizontalOffsetAdjustment && !verticalOffsetAdjustment) {
            if (!cellCache[key]) {
              cellCache[key] = cellRenderer(cellRendererParams);
            }
            renderedCell = cellCache[key];
          } else {
            renderedCell = cellRenderer(cellRendererParams);
          }
          if (renderedCell == null || renderedCell === false) {
            continue;
          }
          if (true) {
            warnAboutMissingStyle(parent, renderedCell);
          }
          renderedCells.push(renderedCell);
        }
      }
      return renderedCells;
    }
    function warnAboutMissingStyle(parent, renderedCell) {
      if (true) {
        if (renderedCell) {
          if (renderedCell.type && renderedCell.type.__internalCellMeasurerFlag) {
            renderedCell = renderedCell.props.children;
          }
          if (renderedCell && renderedCell.props && renderedCell.props.style === void 0 && parent.__warnedAboutMissingStyle !== true) {
            parent.__warnedAboutMissingStyle = true;
            console.warn("Rendered cell should include style property for positioning.");
          }
        }
      }
    }
  }
});

// node_modules/dom-helpers/esm/canUseDOM.js
var canUseDOM_default;
var init_canUseDOM = __esm({
  "node_modules/dom-helpers/esm/canUseDOM.js"() {
    canUseDOM_default = !!(typeof window !== "undefined" && window.document && window.document.createElement);
  }
});

// node_modules/dom-helpers/esm/scrollbarSize.js
var scrollbarSize_exports = {};
__export(scrollbarSize_exports, {
  default: () => scrollbarSize
});
function scrollbarSize(recalc) {
  if (!size && size !== 0 || recalc) {
    if (canUseDOM_default) {
      var scrollDiv = document.createElement("div");
      scrollDiv.style.position = "absolute";
      scrollDiv.style.top = "-9999px";
      scrollDiv.style.width = "50px";
      scrollDiv.style.height = "50px";
      scrollDiv.style.overflow = "scroll";
      document.body.appendChild(scrollDiv);
      size = scrollDiv.offsetWidth - scrollDiv.clientWidth;
      document.body.removeChild(scrollDiv);
    }
  }
  return size;
}
var size;
var init_scrollbarSize = __esm({
  "node_modules/dom-helpers/esm/scrollbarSize.js"() {
    init_canUseDOM();
  }
});

// node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js
var react_lifecycles_compat_es_exports = {};
__export(react_lifecycles_compat_es_exports, {
  polyfill: () => polyfill
});
function componentWillMount() {
  var state = this.constructor.getDerivedStateFromProps(this.props, this.state);
  if (state !== null && state !== void 0) {
    this.setState(state);
  }
}
function componentWillReceiveProps(nextProps) {
  function updater(prevState) {
    var state = this.constructor.getDerivedStateFromProps(nextProps, prevState);
    return state !== null && state !== void 0 ? state : null;
  }
  this.setState(updater.bind(this));
}
function componentWillUpdate(nextProps, nextState) {
  try {
    var prevProps = this.props;
    var prevState = this.state;
    this.props = nextProps;
    this.state = nextState;
    this.__reactInternalSnapshotFlag = true;
    this.__reactInternalSnapshot = this.getSnapshotBeforeUpdate(
      prevProps,
      prevState
    );
  } finally {
    this.props = prevProps;
    this.state = prevState;
  }
}
function polyfill(Component) {
  var prototype = Component.prototype;
  if (!prototype || !prototype.isReactComponent) {
    throw new Error("Can only polyfill class components");
  }
  if (typeof Component.getDerivedStateFromProps !== "function" && typeof prototype.getSnapshotBeforeUpdate !== "function") {
    return Component;
  }
  var foundWillMountName = null;
  var foundWillReceivePropsName = null;
  var foundWillUpdateName = null;
  if (typeof prototype.componentWillMount === "function") {
    foundWillMountName = "componentWillMount";
  } else if (typeof prototype.UNSAFE_componentWillMount === "function") {
    foundWillMountName = "UNSAFE_componentWillMount";
  }
  if (typeof prototype.componentWillReceiveProps === "function") {
    foundWillReceivePropsName = "componentWillReceiveProps";
  } else if (typeof prototype.UNSAFE_componentWillReceiveProps === "function") {
    foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
  }
  if (typeof prototype.componentWillUpdate === "function") {
    foundWillUpdateName = "componentWillUpdate";
  } else if (typeof prototype.UNSAFE_componentWillUpdate === "function") {
    foundWillUpdateName = "UNSAFE_componentWillUpdate";
  }
  if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
    var componentName = Component.displayName || Component.name;
    var newApiName = typeof Component.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
    throw Error(
      "Unsafe legacy lifecycles will not be called for components using new component APIs.\n\n" + componentName + " uses " + newApiName + " but also contains the following legacy lifecycles:" + (foundWillMountName !== null ? "\n  " + foundWillMountName : "") + (foundWillReceivePropsName !== null ? "\n  " + foundWillReceivePropsName : "") + (foundWillUpdateName !== null ? "\n  " + foundWillUpdateName : "") + "\n\nThe above lifecycles should be removed. Learn more about this warning here:\nhttps://fb.me/react-async-component-lifecycle-hooks"
    );
  }
  if (typeof Component.getDerivedStateFromProps === "function") {
    prototype.componentWillMount = componentWillMount;
    prototype.componentWillReceiveProps = componentWillReceiveProps;
  }
  if (typeof prototype.getSnapshotBeforeUpdate === "function") {
    if (typeof prototype.componentDidUpdate !== "function") {
      throw new Error(
        "Cannot polyfill getSnapshotBeforeUpdate() for components that do not define componentDidUpdate() on the prototype"
      );
    }
    prototype.componentWillUpdate = componentWillUpdate;
    var componentDidUpdate = prototype.componentDidUpdate;
    prototype.componentDidUpdate = function componentDidUpdatePolyfill(prevProps, prevState, maybeSnapshot) {
      var snapshot = this.__reactInternalSnapshotFlag ? this.__reactInternalSnapshot : maybeSnapshot;
      componentDidUpdate.call(this, prevProps, prevState, snapshot);
    };
  }
  return Component;
}
var init_react_lifecycles_compat_es = __esm({
  "node_modules/react-lifecycles-compat/react-lifecycles-compat.es.js"() {
    componentWillMount.__suppressDeprecationWarning = true;
    componentWillReceiveProps.__suppressDeprecationWarning = true;
    componentWillUpdate.__suppressDeprecationWarning = true;
  }
});

// node_modules/react-virtualized/dist/commonjs/utils/animationFrame.js
var require_animationFrame = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/utils/animationFrame.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.caf = exports.raf = void 0;
    var win;
    if (typeof window !== "undefined") {
      win = window;
    } else if (typeof self !== "undefined") {
      win = self;
    } else {
      win = {};
    }
    var request = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || win.msRequestAnimationFrame || function(callback) {
      return win.setTimeout(callback, 1e3 / 60);
    };
    var cancel = win.cancelAnimationFrame || win.webkitCancelAnimationFrame || win.mozCancelAnimationFrame || win.oCancelAnimationFrame || win.msCancelAnimationFrame || function(id) {
      win.clearTimeout(id);
    };
    var raf = request;
    exports.raf = raf;
    var caf = cancel;
    exports.caf = caf;
  }
});

// node_modules/react-virtualized/dist/commonjs/utils/requestAnimationTimeout.js
var require_requestAnimationTimeout = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/utils/requestAnimationTimeout.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bpfrpt_proptype_AnimationTimeoutId = exports.requestAnimationTimeout = exports.cancelAnimationTimeout = void 0;
    var _animationFrame = require_animationFrame();
    var _propTypes = _interopRequireDefault(require_prop_types());
    var bpfrpt_proptype_AnimationTimeoutId = false ? null : {
      "id": _propTypes["default"].number.isRequired
    };
    exports.bpfrpt_proptype_AnimationTimeoutId = bpfrpt_proptype_AnimationTimeoutId;
    var cancelAnimationTimeout = function cancelAnimationTimeout2(frame) {
      return (0, _animationFrame.caf)(frame.id);
    };
    exports.cancelAnimationTimeout = cancelAnimationTimeout;
    var requestAnimationTimeout = function requestAnimationTimeout2(callback, delay) {
      var start;
      Promise.resolve().then(function() {
        start = Date.now();
      });
      var timeout = function timeout2() {
        if (Date.now() - start >= delay) {
          callback.call();
        } else {
          frame.id = (0, _animationFrame.raf)(timeout2);
        }
      };
      var frame = {
        id: (0, _animationFrame.raf)(timeout)
      };
      return frame;
    };
    exports.requestAnimationTimeout = requestAnimationTimeout;
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/Grid.js
var require_Grid = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/Grid.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = void 0;
    var _extends2 = _interopRequireDefault(require_extends());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf2 = _interopRequireDefault(require_getPrototypeOf());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var React = _interopRequireWildcard(require_react());
    var _clsx = _interopRequireDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var _calculateSizeAndPositionDataAndUpdateScrollOffset = _interopRequireDefault(require_calculateSizeAndPositionDataAndUpdateScrollOffset());
    var _ScalingCellSizeAndPositionManager = _interopRequireDefault(require_ScalingCellSizeAndPositionManager());
    var _createCallbackMemoizer = _interopRequireDefault(require_createCallbackMemoizer());
    var _defaultOverscanIndicesGetter = _interopRequireWildcard(require_defaultOverscanIndicesGetter());
    var _updateScrollIndexHelper = _interopRequireDefault(require_updateScrollIndexHelper());
    var _defaultCellRangeRenderer = _interopRequireDefault(require_defaultCellRangeRenderer());
    var _scrollbarSize = _interopRequireDefault((init_scrollbarSize(), __toCommonJS(scrollbarSize_exports)));
    var _reactLifecyclesCompat = (init_react_lifecycles_compat_es(), __toCommonJS(react_lifecycles_compat_es_exports));
    var _requestAnimationTimeout = require_requestAnimationTimeout();
    var _types = require_types();
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _class;
    var _temp;
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        if (enumerableOnly) symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        keys.push.apply(keys, symbols);
      }
      return keys;
    }
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = arguments[i] != null ? arguments[i] : {};
        if (i % 2) {
          ownKeys(source, true).forEach(function(key) {
            (0, _defineProperty2["default"])(target, key, source[key]);
          });
        } else if (Object.getOwnPropertyDescriptors) {
          Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
        } else {
          ownKeys(source).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
          });
        }
      }
      return target;
    }
    var DEFAULT_SCROLLING_RESET_TIME_INTERVAL = 150;
    exports.DEFAULT_SCROLLING_RESET_TIME_INTERVAL = DEFAULT_SCROLLING_RESET_TIME_INTERVAL;
    var SCROLL_POSITION_CHANGE_REASONS = {
      OBSERVED: "observed",
      REQUESTED: "requested"
    };
    var renderNull = function renderNull2() {
      return null;
    };
    var Grid = (_temp = _class = function(_React$PureComponent) {
      (0, _inherits2["default"])(Grid2, _React$PureComponent);
      function Grid2(props) {
        var _this;
        (0, _classCallCheck2["default"])(this, Grid2);
        _this = (0, _possibleConstructorReturn2["default"])(this, (0, _getPrototypeOf2["default"])(Grid2).call(this, props));
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onGridRenderedMemoizer", (0, _createCallbackMemoizer["default"])());
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onScrollMemoizer", (0, _createCallbackMemoizer["default"])(false));
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_deferredInvalidateColumnIndex", null);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_deferredInvalidateRowIndex", null);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_recomputeScrollLeftFlag", false);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_recomputeScrollTopFlag", false);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_horizontalScrollBarSize", 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_verticalScrollBarSize", 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_scrollbarPresenceChanged", false);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_scrollingContainer", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_childrenToDisplay", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_columnStartIndex", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_columnStopIndex", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_rowStartIndex", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_rowStopIndex", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_renderedColumnStartIndex", 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_renderedColumnStopIndex", 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_renderedRowStartIndex", 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_renderedRowStopIndex", 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_initialScrollTop", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_initialScrollLeft", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_disablePointerEventsTimeoutId", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_styleCache", {});
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_cellCache", {});
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_debounceScrollEndedCallback", function() {
          _this._disablePointerEventsTimeoutId = null;
          _this.setState({
            isScrolling: false,
            needToResetStyleCache: false
          });
        });
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_invokeOnGridRenderedHelper", function() {
          var onSectionRendered = _this.props.onSectionRendered;
          _this._onGridRenderedMemoizer({
            callback: onSectionRendered,
            indices: {
              columnOverscanStartIndex: _this._columnStartIndex,
              columnOverscanStopIndex: _this._columnStopIndex,
              columnStartIndex: _this._renderedColumnStartIndex,
              columnStopIndex: _this._renderedColumnStopIndex,
              rowOverscanStartIndex: _this._rowStartIndex,
              rowOverscanStopIndex: _this._rowStopIndex,
              rowStartIndex: _this._renderedRowStartIndex,
              rowStopIndex: _this._renderedRowStopIndex
            }
          });
        });
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_setScrollingContainerRef", function(ref) {
          _this._scrollingContainer = ref;
        });
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onScroll", function(event) {
          if (event.target === _this._scrollingContainer) {
            _this.handleScrollEvent(event.target);
          }
        });
        var columnSizeAndPositionManager = new _ScalingCellSizeAndPositionManager["default"]({
          cellCount: props.columnCount,
          cellSizeGetter: function cellSizeGetter(params) {
            return Grid2._wrapSizeGetter(props.columnWidth)(params);
          },
          estimatedCellSize: Grid2._getEstimatedColumnSize(props)
        });
        var rowSizeAndPositionManager = new _ScalingCellSizeAndPositionManager["default"]({
          cellCount: props.rowCount,
          cellSizeGetter: function cellSizeGetter(params) {
            return Grid2._wrapSizeGetter(props.rowHeight)(params);
          },
          estimatedCellSize: Grid2._getEstimatedRowSize(props)
        });
        _this.state = {
          instanceProps: {
            columnSizeAndPositionManager,
            rowSizeAndPositionManager,
            prevColumnWidth: props.columnWidth,
            prevRowHeight: props.rowHeight,
            prevColumnCount: props.columnCount,
            prevRowCount: props.rowCount,
            prevIsScrolling: props.isScrolling === true,
            prevScrollToColumn: props.scrollToColumn,
            prevScrollToRow: props.scrollToRow,
            scrollbarSize: 0,
            scrollbarSizeMeasured: false
          },
          isScrolling: false,
          scrollDirectionHorizontal: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,
          scrollDirectionVertical: _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD,
          scrollLeft: 0,
          scrollTop: 0,
          scrollPositionChangeReason: null,
          needToResetStyleCache: false
        };
        if (props.scrollToRow > 0) {
          _this._initialScrollTop = _this._getCalculatedScrollTop(props, _this.state);
        }
        if (props.scrollToColumn > 0) {
          _this._initialScrollLeft = _this._getCalculatedScrollLeft(props, _this.state);
        }
        return _this;
      }
      (0, _createClass2["default"])(Grid2, [{
        key: "getOffsetForCell",
        value: function getOffsetForCell() {
          var _ref = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref$alignment = _ref.alignment, alignment = _ref$alignment === void 0 ? this.props.scrollToAlignment : _ref$alignment, _ref$columnIndex = _ref.columnIndex, columnIndex = _ref$columnIndex === void 0 ? this.props.scrollToColumn : _ref$columnIndex, _ref$rowIndex = _ref.rowIndex, rowIndex = _ref$rowIndex === void 0 ? this.props.scrollToRow : _ref$rowIndex;
          var offsetProps = _objectSpread({}, this.props, {
            scrollToAlignment: alignment,
            scrollToColumn: columnIndex,
            scrollToRow: rowIndex
          });
          return {
            scrollLeft: this._getCalculatedScrollLeft(offsetProps),
            scrollTop: this._getCalculatedScrollTop(offsetProps)
          };
        }
        /**
         * Gets estimated total rows' height.
         */
      }, {
        key: "getTotalRowsHeight",
        value: function getTotalRowsHeight() {
          return this.state.instanceProps.rowSizeAndPositionManager.getTotalSize();
        }
        /**
         * Gets estimated total columns' width.
         */
      }, {
        key: "getTotalColumnsWidth",
        value: function getTotalColumnsWidth() {
          return this.state.instanceProps.columnSizeAndPositionManager.getTotalSize();
        }
        /**
         * This method handles a scroll event originating from an external scroll control.
         * It's an advanced method and should probably not be used unless you're implementing a custom scroll-bar solution.
         */
      }, {
        key: "handleScrollEvent",
        value: function handleScrollEvent(_ref2) {
          var _ref2$scrollLeft = _ref2.scrollLeft, scrollLeftParam = _ref2$scrollLeft === void 0 ? 0 : _ref2$scrollLeft, _ref2$scrollTop = _ref2.scrollTop, scrollTopParam = _ref2$scrollTop === void 0 ? 0 : _ref2$scrollTop;
          if (scrollTopParam < 0) {
            return;
          }
          this._debounceScrollEnded();
          var _this$props = this.props, autoHeight = _this$props.autoHeight, autoWidth = _this$props.autoWidth, height = _this$props.height, width = _this$props.width;
          var instanceProps = this.state.instanceProps;
          var scrollbarSize2 = instanceProps.scrollbarSize;
          var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
          var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
          var scrollLeft = Math.min(Math.max(0, totalColumnsWidth - width + scrollbarSize2), scrollLeftParam);
          var scrollTop = Math.min(Math.max(0, totalRowsHeight - height + scrollbarSize2), scrollTopParam);
          if (this.state.scrollLeft !== scrollLeft || this.state.scrollTop !== scrollTop) {
            var scrollDirectionHorizontal = scrollLeft !== this.state.scrollLeft ? scrollLeft > this.state.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionHorizontal;
            var scrollDirectionVertical = scrollTop !== this.state.scrollTop ? scrollTop > this.state.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD : this.state.scrollDirectionVertical;
            var newState = {
              isScrolling: true,
              scrollDirectionHorizontal,
              scrollDirectionVertical,
              scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.OBSERVED
            };
            if (!autoHeight) {
              newState.scrollTop = scrollTop;
            }
            if (!autoWidth) {
              newState.scrollLeft = scrollLeft;
            }
            newState.needToResetStyleCache = false;
            this.setState(newState);
          }
          this._invokeOnScrollMemoizer({
            scrollLeft,
            scrollTop,
            totalColumnsWidth,
            totalRowsHeight
          });
        }
        /**
         * Invalidate Grid size and recompute visible cells.
         * This is a deferred wrapper for recomputeGridSize().
         * It sets a flag to be evaluated on cDM/cDU to avoid unnecessary renders.
         * This method is intended for advanced use-cases like CellMeasurer.
         */
        // @TODO (bvaughn) Add automated test coverage for this.
      }, {
        key: "invalidateCellSizeAfterRender",
        value: function invalidateCellSizeAfterRender(_ref3) {
          var columnIndex = _ref3.columnIndex, rowIndex = _ref3.rowIndex;
          this._deferredInvalidateColumnIndex = typeof this._deferredInvalidateColumnIndex === "number" ? Math.min(this._deferredInvalidateColumnIndex, columnIndex) : columnIndex;
          this._deferredInvalidateRowIndex = typeof this._deferredInvalidateRowIndex === "number" ? Math.min(this._deferredInvalidateRowIndex, rowIndex) : rowIndex;
        }
        /**
         * Pre-measure all columns and rows in a Grid.
         * Typically cells are only measured as needed and estimated sizes are used for cells that have not yet been measured.
         * This method ensures that the next call to getTotalSize() returns an exact size (as opposed to just an estimated one).
         */
      }, {
        key: "measureAllCells",
        value: function measureAllCells() {
          var _this$props2 = this.props, columnCount = _this$props2.columnCount, rowCount = _this$props2.rowCount;
          var instanceProps = this.state.instanceProps;
          instanceProps.columnSizeAndPositionManager.getSizeAndPositionOfCell(columnCount - 1);
          instanceProps.rowSizeAndPositionManager.getSizeAndPositionOfCell(rowCount - 1);
        }
        /**
         * Forced recompute of row heights and column widths.
         * This function should be called if dynamic column or row sizes have changed but nothing else has.
         * Since Grid only receives :columnCount and :rowCount it has no way of detecting when the underlying data changes.
         */
      }, {
        key: "recomputeGridSize",
        value: function recomputeGridSize() {
          var _ref4 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref4$columnIndex = _ref4.columnIndex, columnIndex = _ref4$columnIndex === void 0 ? 0 : _ref4$columnIndex, _ref4$rowIndex = _ref4.rowIndex, rowIndex = _ref4$rowIndex === void 0 ? 0 : _ref4$rowIndex;
          var _this$props3 = this.props, scrollToColumn = _this$props3.scrollToColumn, scrollToRow = _this$props3.scrollToRow;
          var instanceProps = this.state.instanceProps;
          instanceProps.columnSizeAndPositionManager.resetCell(columnIndex);
          instanceProps.rowSizeAndPositionManager.resetCell(rowIndex);
          this._recomputeScrollLeftFlag = scrollToColumn >= 0 && (this.state.scrollDirectionHorizontal === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? columnIndex <= scrollToColumn : columnIndex >= scrollToColumn);
          this._recomputeScrollTopFlag = scrollToRow >= 0 && (this.state.scrollDirectionVertical === _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD ? rowIndex <= scrollToRow : rowIndex >= scrollToRow);
          this._styleCache = {};
          this._cellCache = {};
          this.forceUpdate();
        }
        /**
         * Ensure column and row are visible.
         */
      }, {
        key: "scrollToCell",
        value: function scrollToCell(_ref5) {
          var columnIndex = _ref5.columnIndex, rowIndex = _ref5.rowIndex;
          var columnCount = this.props.columnCount;
          var props = this.props;
          if (columnCount > 1 && columnIndex !== void 0) {
            this._updateScrollLeftForScrollToColumn(_objectSpread({}, props, {
              scrollToColumn: columnIndex
            }));
          }
          if (rowIndex !== void 0) {
            this._updateScrollTopForScrollToRow(_objectSpread({}, props, {
              scrollToRow: rowIndex
            }));
          }
        }
      }, {
        key: "componentDidMount",
        value: function componentDidMount() {
          var _this$props4 = this.props, getScrollbarSize = _this$props4.getScrollbarSize, height = _this$props4.height, scrollLeft = _this$props4.scrollLeft, scrollToColumn = _this$props4.scrollToColumn, scrollTop = _this$props4.scrollTop, scrollToRow = _this$props4.scrollToRow, width = _this$props4.width;
          var instanceProps = this.state.instanceProps;
          this._initialScrollTop = 0;
          this._initialScrollLeft = 0;
          this._handleInvalidatedGridSize();
          if (!instanceProps.scrollbarSizeMeasured) {
            this.setState(function(prevState) {
              var stateUpdate2 = _objectSpread({}, prevState, {
                needToResetStyleCache: false
              });
              stateUpdate2.instanceProps.scrollbarSize = getScrollbarSize();
              stateUpdate2.instanceProps.scrollbarSizeMeasured = true;
              return stateUpdate2;
            });
          }
          if (typeof scrollLeft === "number" && scrollLeft >= 0 || typeof scrollTop === "number" && scrollTop >= 0) {
            var stateUpdate = Grid2._getScrollToPositionStateUpdate({
              prevState: this.state,
              scrollLeft,
              scrollTop
            });
            if (stateUpdate) {
              stateUpdate.needToResetStyleCache = false;
              this.setState(stateUpdate);
            }
          }
          if (this._scrollingContainer) {
            if (this._scrollingContainer.scrollLeft !== this.state.scrollLeft) {
              this._scrollingContainer.scrollLeft = this.state.scrollLeft;
            }
            if (this._scrollingContainer.scrollTop !== this.state.scrollTop) {
              this._scrollingContainer.scrollTop = this.state.scrollTop;
            }
          }
          var sizeIsBiggerThanZero = height > 0 && width > 0;
          if (scrollToColumn >= 0 && sizeIsBiggerThanZero) {
            this._updateScrollLeftForScrollToColumn();
          }
          if (scrollToRow >= 0 && sizeIsBiggerThanZero) {
            this._updateScrollTopForScrollToRow();
          }
          this._invokeOnGridRenderedHelper();
          this._invokeOnScrollMemoizer({
            scrollLeft: scrollLeft || 0,
            scrollTop: scrollTop || 0,
            totalColumnsWidth: instanceProps.columnSizeAndPositionManager.getTotalSize(),
            totalRowsHeight: instanceProps.rowSizeAndPositionManager.getTotalSize()
          });
          this._maybeCallOnScrollbarPresenceChange();
        }
        /**
         * @private
         * This method updates scrollLeft/scrollTop in state for the following conditions:
         * 1) New scroll-to-cell props have been set
         */
      }, {
        key: "componentDidUpdate",
        value: function componentDidUpdate(prevProps, prevState) {
          var _this2 = this;
          var _this$props5 = this.props, autoHeight = _this$props5.autoHeight, autoWidth = _this$props5.autoWidth, columnCount = _this$props5.columnCount, height = _this$props5.height, rowCount = _this$props5.rowCount, scrollToAlignment = _this$props5.scrollToAlignment, scrollToColumn = _this$props5.scrollToColumn, scrollToRow = _this$props5.scrollToRow, width = _this$props5.width;
          var _this$state = this.state, scrollLeft = _this$state.scrollLeft, scrollPositionChangeReason = _this$state.scrollPositionChangeReason, scrollTop = _this$state.scrollTop, instanceProps = _this$state.instanceProps;
          this._handleInvalidatedGridSize();
          var columnOrRowCountJustIncreasedFromZero = columnCount > 0 && prevProps.columnCount === 0 || rowCount > 0 && prevProps.rowCount === 0;
          if (scrollPositionChangeReason === SCROLL_POSITION_CHANGE_REASONS.REQUESTED) {
            if (!autoWidth && scrollLeft >= 0 && (scrollLeft !== this._scrollingContainer.scrollLeft || columnOrRowCountJustIncreasedFromZero)) {
              this._scrollingContainer.scrollLeft = scrollLeft;
            }
            if (!autoHeight && scrollTop >= 0 && (scrollTop !== this._scrollingContainer.scrollTop || columnOrRowCountJustIncreasedFromZero)) {
              this._scrollingContainer.scrollTop = scrollTop;
            }
          }
          var sizeJustIncreasedFromZero = (prevProps.width === 0 || prevProps.height === 0) && height > 0 && width > 0;
          if (this._recomputeScrollLeftFlag) {
            this._recomputeScrollLeftFlag = false;
            this._updateScrollLeftForScrollToColumn(this.props);
          } else {
            (0, _updateScrollIndexHelper["default"])({
              cellSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,
              previousCellsCount: prevProps.columnCount,
              previousCellSize: prevProps.columnWidth,
              previousScrollToAlignment: prevProps.scrollToAlignment,
              previousScrollToIndex: prevProps.scrollToColumn,
              previousSize: prevProps.width,
              scrollOffset: scrollLeft,
              scrollToAlignment,
              scrollToIndex: scrollToColumn,
              size: width,
              sizeJustIncreasedFromZero,
              updateScrollIndexCallback: function updateScrollIndexCallback() {
                return _this2._updateScrollLeftForScrollToColumn(_this2.props);
              }
            });
          }
          if (this._recomputeScrollTopFlag) {
            this._recomputeScrollTopFlag = false;
            this._updateScrollTopForScrollToRow(this.props);
          } else {
            (0, _updateScrollIndexHelper["default"])({
              cellSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,
              previousCellsCount: prevProps.rowCount,
              previousCellSize: prevProps.rowHeight,
              previousScrollToAlignment: prevProps.scrollToAlignment,
              previousScrollToIndex: prevProps.scrollToRow,
              previousSize: prevProps.height,
              scrollOffset: scrollTop,
              scrollToAlignment,
              scrollToIndex: scrollToRow,
              size: height,
              sizeJustIncreasedFromZero,
              updateScrollIndexCallback: function updateScrollIndexCallback() {
                return _this2._updateScrollTopForScrollToRow(_this2.props);
              }
            });
          }
          this._invokeOnGridRenderedHelper();
          if (scrollLeft !== prevState.scrollLeft || scrollTop !== prevState.scrollTop) {
            var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
            var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
            this._invokeOnScrollMemoizer({
              scrollLeft,
              scrollTop,
              totalColumnsWidth,
              totalRowsHeight
            });
          }
          this._maybeCallOnScrollbarPresenceChange();
        }
      }, {
        key: "componentWillUnmount",
        value: function componentWillUnmount() {
          if (this._disablePointerEventsTimeoutId) {
            (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);
          }
        }
        /**
         * This method updates scrollLeft/scrollTop in state for the following conditions:
         * 1) Empty content (0 rows or columns)
         * 2) New scroll props overriding the current state
         * 3) Cells-count or cells-size has changed, making previous scroll offsets invalid
         */
      }, {
        key: "render",
        value: function render() {
          var _this$props6 = this.props, autoContainerWidth = _this$props6.autoContainerWidth, autoHeight = _this$props6.autoHeight, autoWidth = _this$props6.autoWidth, className = _this$props6.className, containerProps = _this$props6.containerProps, containerRole = _this$props6.containerRole, containerStyle = _this$props6.containerStyle, height = _this$props6.height, id = _this$props6.id, noContentRenderer = _this$props6.noContentRenderer, role = _this$props6.role, style = _this$props6.style, tabIndex = _this$props6.tabIndex, width = _this$props6.width;
          var _this$state2 = this.state, instanceProps = _this$state2.instanceProps, needToResetStyleCache = _this$state2.needToResetStyleCache;
          var isScrolling = this._isScrolling();
          var gridStyle = {
            boxSizing: "border-box",
            direction: "ltr",
            height: autoHeight ? "auto" : height,
            position: "relative",
            width: autoWidth ? "auto" : width,
            WebkitOverflowScrolling: "touch",
            willChange: "transform"
          };
          if (needToResetStyleCache) {
            this._styleCache = {};
          }
          if (!this.state.isScrolling) {
            this._resetStyleCache();
          }
          this._calculateChildrenToRender(this.props, this.state);
          var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
          var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
          var verticalScrollBarSize = totalRowsHeight > height ? instanceProps.scrollbarSize : 0;
          var horizontalScrollBarSize = totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;
          if (horizontalScrollBarSize !== this._horizontalScrollBarSize || verticalScrollBarSize !== this._verticalScrollBarSize) {
            this._horizontalScrollBarSize = horizontalScrollBarSize;
            this._verticalScrollBarSize = verticalScrollBarSize;
            this._scrollbarPresenceChanged = true;
          }
          gridStyle.overflowX = totalColumnsWidth + verticalScrollBarSize <= width ? "hidden" : "auto";
          gridStyle.overflowY = totalRowsHeight + horizontalScrollBarSize <= height ? "hidden" : "auto";
          var childrenToDisplay = this._childrenToDisplay;
          var showNoContentRenderer = childrenToDisplay.length === 0 && height > 0 && width > 0;
          return React.createElement("div", (0, _extends2["default"])({
            ref: this._setScrollingContainerRef
          }, containerProps, {
            "aria-label": this.props["aria-label"],
            "aria-readonly": this.props["aria-readonly"],
            className: (0, _clsx["default"])("ReactVirtualized__Grid", className),
            id,
            onScroll: this._onScroll,
            role,
            style: _objectSpread({}, gridStyle, {}, style),
            tabIndex
          }), childrenToDisplay.length > 0 && React.createElement("div", {
            className: "ReactVirtualized__Grid__innerScrollContainer",
            role: containerRole,
            style: _objectSpread({
              width: autoContainerWidth ? "auto" : totalColumnsWidth,
              height: totalRowsHeight,
              maxWidth: totalColumnsWidth,
              maxHeight: totalRowsHeight,
              overflow: "hidden",
              pointerEvents: isScrolling ? "none" : "",
              position: "relative"
            }, containerStyle)
          }, childrenToDisplay), showNoContentRenderer && noContentRenderer());
        }
        /* ---------------------------- Helper methods ---------------------------- */
      }, {
        key: "_calculateChildrenToRender",
        value: function _calculateChildrenToRender() {
          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
          var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
          var cellRenderer = props.cellRenderer, cellRangeRenderer = props.cellRangeRenderer, columnCount = props.columnCount, deferredMeasurementCache = props.deferredMeasurementCache, height = props.height, overscanColumnCount = props.overscanColumnCount, overscanIndicesGetter = props.overscanIndicesGetter, overscanRowCount = props.overscanRowCount, rowCount = props.rowCount, width = props.width, isScrollingOptOut = props.isScrollingOptOut;
          var scrollDirectionHorizontal = state.scrollDirectionHorizontal, scrollDirectionVertical = state.scrollDirectionVertical, instanceProps = state.instanceProps;
          var scrollTop = this._initialScrollTop > 0 ? this._initialScrollTop : state.scrollTop;
          var scrollLeft = this._initialScrollLeft > 0 ? this._initialScrollLeft : state.scrollLeft;
          var isScrolling = this._isScrolling(props, state);
          this._childrenToDisplay = [];
          if (height > 0 && width > 0) {
            var visibleColumnIndices = instanceProps.columnSizeAndPositionManager.getVisibleCellRange({
              containerSize: width,
              offset: scrollLeft
            });
            var visibleRowIndices = instanceProps.rowSizeAndPositionManager.getVisibleCellRange({
              containerSize: height,
              offset: scrollTop
            });
            var horizontalOffsetAdjustment = instanceProps.columnSizeAndPositionManager.getOffsetAdjustment({
              containerSize: width,
              offset: scrollLeft
            });
            var verticalOffsetAdjustment = instanceProps.rowSizeAndPositionManager.getOffsetAdjustment({
              containerSize: height,
              offset: scrollTop
            });
            this._renderedColumnStartIndex = visibleColumnIndices.start;
            this._renderedColumnStopIndex = visibleColumnIndices.stop;
            this._renderedRowStartIndex = visibleRowIndices.start;
            this._renderedRowStopIndex = visibleRowIndices.stop;
            var overscanColumnIndices = overscanIndicesGetter({
              direction: "horizontal",
              cellCount: columnCount,
              overscanCellsCount: overscanColumnCount,
              scrollDirection: scrollDirectionHorizontal,
              startIndex: typeof visibleColumnIndices.start === "number" ? visibleColumnIndices.start : 0,
              stopIndex: typeof visibleColumnIndices.stop === "number" ? visibleColumnIndices.stop : -1
            });
            var overscanRowIndices = overscanIndicesGetter({
              direction: "vertical",
              cellCount: rowCount,
              overscanCellsCount: overscanRowCount,
              scrollDirection: scrollDirectionVertical,
              startIndex: typeof visibleRowIndices.start === "number" ? visibleRowIndices.start : 0,
              stopIndex: typeof visibleRowIndices.stop === "number" ? visibleRowIndices.stop : -1
            });
            var columnStartIndex = overscanColumnIndices.overscanStartIndex;
            var columnStopIndex = overscanColumnIndices.overscanStopIndex;
            var rowStartIndex = overscanRowIndices.overscanStartIndex;
            var rowStopIndex = overscanRowIndices.overscanStopIndex;
            if (deferredMeasurementCache) {
              if (!deferredMeasurementCache.hasFixedHeight()) {
                for (var rowIndex = rowStartIndex; rowIndex <= rowStopIndex; rowIndex++) {
                  if (!deferredMeasurementCache.has(rowIndex, 0)) {
                    columnStartIndex = 0;
                    columnStopIndex = columnCount - 1;
                    break;
                  }
                }
              }
              if (!deferredMeasurementCache.hasFixedWidth()) {
                for (var columnIndex = columnStartIndex; columnIndex <= columnStopIndex; columnIndex++) {
                  if (!deferredMeasurementCache.has(0, columnIndex)) {
                    rowStartIndex = 0;
                    rowStopIndex = rowCount - 1;
                    break;
                  }
                }
              }
            }
            this._childrenToDisplay = cellRangeRenderer({
              cellCache: this._cellCache,
              cellRenderer,
              columnSizeAndPositionManager: instanceProps.columnSizeAndPositionManager,
              columnStartIndex,
              columnStopIndex,
              deferredMeasurementCache,
              horizontalOffsetAdjustment,
              isScrolling,
              isScrollingOptOut,
              parent: this,
              rowSizeAndPositionManager: instanceProps.rowSizeAndPositionManager,
              rowStartIndex,
              rowStopIndex,
              scrollLeft,
              scrollTop,
              styleCache: this._styleCache,
              verticalOffsetAdjustment,
              visibleColumnIndices,
              visibleRowIndices
            });
            this._columnStartIndex = columnStartIndex;
            this._columnStopIndex = columnStopIndex;
            this._rowStartIndex = rowStartIndex;
            this._rowStopIndex = rowStopIndex;
          }
        }
        /**
         * Sets an :isScrolling flag for a small window of time.
         * This flag is used to disable pointer events on the scrollable portion of the Grid.
         * This prevents jerky/stuttery mouse-wheel scrolling.
         */
      }, {
        key: "_debounceScrollEnded",
        value: function _debounceScrollEnded() {
          var scrollingResetTimeInterval = this.props.scrollingResetTimeInterval;
          if (this._disablePointerEventsTimeoutId) {
            (0, _requestAnimationTimeout.cancelAnimationTimeout)(this._disablePointerEventsTimeoutId);
          }
          this._disablePointerEventsTimeoutId = (0, _requestAnimationTimeout.requestAnimationTimeout)(this._debounceScrollEndedCallback, scrollingResetTimeInterval);
        }
      }, {
        key: "_handleInvalidatedGridSize",
        /**
         * Check for batched CellMeasurer size invalidations.
         * This will occur the first time one or more previously unmeasured cells are rendered.
         */
        value: function _handleInvalidatedGridSize() {
          if (typeof this._deferredInvalidateColumnIndex === "number" && typeof this._deferredInvalidateRowIndex === "number") {
            var columnIndex = this._deferredInvalidateColumnIndex;
            var rowIndex = this._deferredInvalidateRowIndex;
            this._deferredInvalidateColumnIndex = null;
            this._deferredInvalidateRowIndex = null;
            this.recomputeGridSize({
              columnIndex,
              rowIndex
            });
          }
        }
      }, {
        key: "_invokeOnScrollMemoizer",
        value: function _invokeOnScrollMemoizer(_ref6) {
          var _this3 = this;
          var scrollLeft = _ref6.scrollLeft, scrollTop = _ref6.scrollTop, totalColumnsWidth = _ref6.totalColumnsWidth, totalRowsHeight = _ref6.totalRowsHeight;
          this._onScrollMemoizer({
            callback: function callback(_ref7) {
              var scrollLeft2 = _ref7.scrollLeft, scrollTop2 = _ref7.scrollTop;
              var _this3$props = _this3.props, height = _this3$props.height, onScroll = _this3$props.onScroll, width = _this3$props.width;
              onScroll({
                clientHeight: height,
                clientWidth: width,
                scrollHeight: totalRowsHeight,
                scrollLeft: scrollLeft2,
                scrollTop: scrollTop2,
                scrollWidth: totalColumnsWidth
              });
            },
            indices: {
              scrollLeft,
              scrollTop
            }
          });
        }
      }, {
        key: "_isScrolling",
        value: function _isScrolling() {
          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
          var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
          return Object.hasOwnProperty.call(props, "isScrolling") ? Boolean(props.isScrolling) : Boolean(state.isScrolling);
        }
      }, {
        key: "_maybeCallOnScrollbarPresenceChange",
        value: function _maybeCallOnScrollbarPresenceChange() {
          if (this._scrollbarPresenceChanged) {
            var onScrollbarPresenceChange = this.props.onScrollbarPresenceChange;
            this._scrollbarPresenceChanged = false;
            onScrollbarPresenceChange({
              horizontal: this._horizontalScrollBarSize > 0,
              size: this.state.instanceProps.scrollbarSize,
              vertical: this._verticalScrollBarSize > 0
            });
          }
        }
      }, {
        key: "scrollToPosition",
        /**
         * Scroll to the specified offset(s).
         * Useful for animating position changes.
         */
        value: function scrollToPosition(_ref8) {
          var scrollLeft = _ref8.scrollLeft, scrollTop = _ref8.scrollTop;
          var stateUpdate = Grid2._getScrollToPositionStateUpdate({
            prevState: this.state,
            scrollLeft,
            scrollTop
          });
          if (stateUpdate) {
            stateUpdate.needToResetStyleCache = false;
            this.setState(stateUpdate);
          }
        }
      }, {
        key: "_getCalculatedScrollLeft",
        value: function _getCalculatedScrollLeft() {
          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
          var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
          return Grid2._getCalculatedScrollLeft(props, state);
        }
      }, {
        key: "_updateScrollLeftForScrollToColumn",
        value: function _updateScrollLeftForScrollToColumn() {
          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
          var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
          var stateUpdate = Grid2._getScrollLeftForScrollToColumnStateUpdate(props, state);
          if (stateUpdate) {
            stateUpdate.needToResetStyleCache = false;
            this.setState(stateUpdate);
          }
        }
      }, {
        key: "_getCalculatedScrollTop",
        value: function _getCalculatedScrollTop() {
          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
          var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
          return Grid2._getCalculatedScrollTop(props, state);
        }
      }, {
        key: "_resetStyleCache",
        value: function _resetStyleCache() {
          var styleCache = this._styleCache;
          var cellCache = this._cellCache;
          var isScrollingOptOut = this.props.isScrollingOptOut;
          this._cellCache = {};
          this._styleCache = {};
          for (var rowIndex = this._rowStartIndex; rowIndex <= this._rowStopIndex; rowIndex++) {
            for (var columnIndex = this._columnStartIndex; columnIndex <= this._columnStopIndex; columnIndex++) {
              var key = "".concat(rowIndex, "-").concat(columnIndex);
              this._styleCache[key] = styleCache[key];
              if (isScrollingOptOut) {
                this._cellCache[key] = cellCache[key];
              }
            }
          }
        }
      }, {
        key: "_updateScrollTopForScrollToRow",
        value: function _updateScrollTopForScrollToRow() {
          var props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.props;
          var state = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : this.state;
          var stateUpdate = Grid2._getScrollTopForScrollToRowStateUpdate(props, state);
          if (stateUpdate) {
            stateUpdate.needToResetStyleCache = false;
            this.setState(stateUpdate);
          }
        }
      }], [{
        key: "getDerivedStateFromProps",
        value: function getDerivedStateFromProps(nextProps, prevState) {
          var newState = {};
          if (nextProps.columnCount === 0 && prevState.scrollLeft !== 0 || nextProps.rowCount === 0 && prevState.scrollTop !== 0) {
            newState.scrollLeft = 0;
            newState.scrollTop = 0;
          } else if (nextProps.scrollLeft !== prevState.scrollLeft && nextProps.scrollToColumn < 0 || nextProps.scrollTop !== prevState.scrollTop && nextProps.scrollToRow < 0) {
            Object.assign(newState, Grid2._getScrollToPositionStateUpdate({
              prevState,
              scrollLeft: nextProps.scrollLeft,
              scrollTop: nextProps.scrollTop
            }));
          }
          var instanceProps = prevState.instanceProps;
          newState.needToResetStyleCache = false;
          if (nextProps.columnWidth !== instanceProps.prevColumnWidth || nextProps.rowHeight !== instanceProps.prevRowHeight) {
            newState.needToResetStyleCache = true;
          }
          instanceProps.columnSizeAndPositionManager.configure({
            cellCount: nextProps.columnCount,
            estimatedCellSize: Grid2._getEstimatedColumnSize(nextProps),
            cellSizeGetter: Grid2._wrapSizeGetter(nextProps.columnWidth)
          });
          instanceProps.rowSizeAndPositionManager.configure({
            cellCount: nextProps.rowCount,
            estimatedCellSize: Grid2._getEstimatedRowSize(nextProps),
            cellSizeGetter: Grid2._wrapSizeGetter(nextProps.rowHeight)
          });
          if (instanceProps.prevColumnCount === 0 || instanceProps.prevRowCount === 0) {
            instanceProps.prevColumnCount = 0;
            instanceProps.prevRowCount = 0;
          }
          if (nextProps.autoHeight && nextProps.isScrolling === false && instanceProps.prevIsScrolling === true) {
            Object.assign(newState, {
              isScrolling: false
            });
          }
          var maybeStateA;
          var maybeStateB;
          (0, _calculateSizeAndPositionDataAndUpdateScrollOffset["default"])({
            cellCount: instanceProps.prevColumnCount,
            cellSize: typeof instanceProps.prevColumnWidth === "number" ? instanceProps.prevColumnWidth : null,
            computeMetadataCallback: function computeMetadataCallback() {
              return instanceProps.columnSizeAndPositionManager.resetCell(0);
            },
            computeMetadataCallbackProps: nextProps,
            nextCellsCount: nextProps.columnCount,
            nextCellSize: typeof nextProps.columnWidth === "number" ? nextProps.columnWidth : null,
            nextScrollToIndex: nextProps.scrollToColumn,
            scrollToIndex: instanceProps.prevScrollToColumn,
            updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {
              maybeStateA = Grid2._getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState);
            }
          });
          (0, _calculateSizeAndPositionDataAndUpdateScrollOffset["default"])({
            cellCount: instanceProps.prevRowCount,
            cellSize: typeof instanceProps.prevRowHeight === "number" ? instanceProps.prevRowHeight : null,
            computeMetadataCallback: function computeMetadataCallback() {
              return instanceProps.rowSizeAndPositionManager.resetCell(0);
            },
            computeMetadataCallbackProps: nextProps,
            nextCellsCount: nextProps.rowCount,
            nextCellSize: typeof nextProps.rowHeight === "number" ? nextProps.rowHeight : null,
            nextScrollToIndex: nextProps.scrollToRow,
            scrollToIndex: instanceProps.prevScrollToRow,
            updateScrollOffsetForScrollToIndex: function updateScrollOffsetForScrollToIndex() {
              maybeStateB = Grid2._getScrollTopForScrollToRowStateUpdate(nextProps, prevState);
            }
          });
          instanceProps.prevColumnCount = nextProps.columnCount;
          instanceProps.prevColumnWidth = nextProps.columnWidth;
          instanceProps.prevIsScrolling = nextProps.isScrolling === true;
          instanceProps.prevRowCount = nextProps.rowCount;
          instanceProps.prevRowHeight = nextProps.rowHeight;
          instanceProps.prevScrollToColumn = nextProps.scrollToColumn;
          instanceProps.prevScrollToRow = nextProps.scrollToRow;
          instanceProps.scrollbarSize = nextProps.getScrollbarSize();
          if (instanceProps.scrollbarSize === void 0) {
            instanceProps.scrollbarSizeMeasured = false;
            instanceProps.scrollbarSize = 0;
          } else {
            instanceProps.scrollbarSizeMeasured = true;
          }
          newState.instanceProps = instanceProps;
          return _objectSpread({}, newState, {}, maybeStateA, {}, maybeStateB);
        }
      }, {
        key: "_getEstimatedColumnSize",
        value: function _getEstimatedColumnSize(props) {
          return typeof props.columnWidth === "number" ? props.columnWidth : props.estimatedColumnSize;
        }
      }, {
        key: "_getEstimatedRowSize",
        value: function _getEstimatedRowSize(props) {
          return typeof props.rowHeight === "number" ? props.rowHeight : props.estimatedRowSize;
        }
      }, {
        key: "_getScrollToPositionStateUpdate",
        /**
         * Get the updated state after scrolling to
         * scrollLeft and scrollTop
         */
        value: function _getScrollToPositionStateUpdate(_ref9) {
          var prevState = _ref9.prevState, scrollLeft = _ref9.scrollLeft, scrollTop = _ref9.scrollTop;
          var newState = {
            scrollPositionChangeReason: SCROLL_POSITION_CHANGE_REASONS.REQUESTED
          };
          if (typeof scrollLeft === "number" && scrollLeft >= 0) {
            newState.scrollDirectionHorizontal = scrollLeft > prevState.scrollLeft ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;
            newState.scrollLeft = scrollLeft;
          }
          if (typeof scrollTop === "number" && scrollTop >= 0) {
            newState.scrollDirectionVertical = scrollTop > prevState.scrollTop ? _defaultOverscanIndicesGetter.SCROLL_DIRECTION_FORWARD : _defaultOverscanIndicesGetter.SCROLL_DIRECTION_BACKWARD;
            newState.scrollTop = scrollTop;
          }
          if (typeof scrollLeft === "number" && scrollLeft >= 0 && scrollLeft !== prevState.scrollLeft || typeof scrollTop === "number" && scrollTop >= 0 && scrollTop !== prevState.scrollTop) {
            return newState;
          }
          return {};
        }
      }, {
        key: "_wrapSizeGetter",
        value: function _wrapSizeGetter(value) {
          return typeof value === "function" ? value : function() {
            return value;
          };
        }
      }, {
        key: "_getCalculatedScrollLeft",
        value: function _getCalculatedScrollLeft(nextProps, prevState) {
          var columnCount = nextProps.columnCount, height = nextProps.height, scrollToAlignment = nextProps.scrollToAlignment, scrollToColumn = nextProps.scrollToColumn, width = nextProps.width;
          var scrollLeft = prevState.scrollLeft, instanceProps = prevState.instanceProps;
          if (columnCount > 0) {
            var finalColumn = columnCount - 1;
            var targetIndex = scrollToColumn < 0 ? finalColumn : Math.min(finalColumn, scrollToColumn);
            var totalRowsHeight = instanceProps.rowSizeAndPositionManager.getTotalSize();
            var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalRowsHeight > height ? instanceProps.scrollbarSize : 0;
            return instanceProps.columnSizeAndPositionManager.getUpdatedOffsetForIndex({
              align: scrollToAlignment,
              containerSize: width - scrollBarSize,
              currentOffset: scrollLeft,
              targetIndex
            });
          }
          return 0;
        }
      }, {
        key: "_getScrollLeftForScrollToColumnStateUpdate",
        value: function _getScrollLeftForScrollToColumnStateUpdate(nextProps, prevState) {
          var scrollLeft = prevState.scrollLeft;
          var calculatedScrollLeft = Grid2._getCalculatedScrollLeft(nextProps, prevState);
          if (typeof calculatedScrollLeft === "number" && calculatedScrollLeft >= 0 && scrollLeft !== calculatedScrollLeft) {
            return Grid2._getScrollToPositionStateUpdate({
              prevState,
              scrollLeft: calculatedScrollLeft,
              scrollTop: -1
            });
          }
          return {};
        }
      }, {
        key: "_getCalculatedScrollTop",
        value: function _getCalculatedScrollTop(nextProps, prevState) {
          var height = nextProps.height, rowCount = nextProps.rowCount, scrollToAlignment = nextProps.scrollToAlignment, scrollToRow = nextProps.scrollToRow, width = nextProps.width;
          var scrollTop = prevState.scrollTop, instanceProps = prevState.instanceProps;
          if (rowCount > 0) {
            var finalRow = rowCount - 1;
            var targetIndex = scrollToRow < 0 ? finalRow : Math.min(finalRow, scrollToRow);
            var totalColumnsWidth = instanceProps.columnSizeAndPositionManager.getTotalSize();
            var scrollBarSize = instanceProps.scrollbarSizeMeasured && totalColumnsWidth > width ? instanceProps.scrollbarSize : 0;
            return instanceProps.rowSizeAndPositionManager.getUpdatedOffsetForIndex({
              align: scrollToAlignment,
              containerSize: height - scrollBarSize,
              currentOffset: scrollTop,
              targetIndex
            });
          }
          return 0;
        }
      }, {
        key: "_getScrollTopForScrollToRowStateUpdate",
        value: function _getScrollTopForScrollToRowStateUpdate(nextProps, prevState) {
          var scrollTop = prevState.scrollTop;
          var calculatedScrollTop = Grid2._getCalculatedScrollTop(nextProps, prevState);
          if (typeof calculatedScrollTop === "number" && calculatedScrollTop >= 0 && scrollTop !== calculatedScrollTop) {
            return Grid2._getScrollToPositionStateUpdate({
              prevState,
              scrollLeft: -1,
              scrollTop: calculatedScrollTop
            });
          }
          return {};
        }
      }]);
      return Grid2;
    }(React.PureComponent), (0, _defineProperty2["default"])(_class, "propTypes", false ? null : {
      "aria-label": _propTypes["default"].string.isRequired,
      "aria-readonly": _propTypes["default"].bool,
      /**
       * Set the width of the inner scrollable container to 'auto'.
       * This is useful for single-column Grids to ensure that the column doesn't extend below a vertical scrollbar.
       */
      "autoContainerWidth": _propTypes["default"].bool.isRequired,
      /**
       * Removes fixed height from the scrollingContainer so that the total height of rows can stretch the window.
       * Intended for use with WindowScroller
       */
      "autoHeight": _propTypes["default"].bool.isRequired,
      /**
       * Removes fixed width from the scrollingContainer so that the total width of rows can stretch the window.
       * Intended for use with WindowScroller
       */
      "autoWidth": _propTypes["default"].bool.isRequired,
      /** Responsible for rendering a cell given an row and column index.  */
      "cellRenderer": function cellRenderer() {
        return (typeof _types.bpfrpt_proptype_CellRenderer === "function" ? _types.bpfrpt_proptype_CellRenderer.isRequired ? _types.bpfrpt_proptype_CellRenderer.isRequired : _types.bpfrpt_proptype_CellRenderer : _propTypes["default"].shape(_types.bpfrpt_proptype_CellRenderer).isRequired).apply(this, arguments);
      },
      /** Responsible for rendering a group of cells given their index ranges.  */
      "cellRangeRenderer": function cellRangeRenderer() {
        return (typeof _types.bpfrpt_proptype_CellRangeRenderer === "function" ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired ? _types.bpfrpt_proptype_CellRangeRenderer.isRequired : _types.bpfrpt_proptype_CellRangeRenderer : _propTypes["default"].shape(_types.bpfrpt_proptype_CellRangeRenderer).isRequired).apply(this, arguments);
      },
      /** Optional custom CSS class name to attach to root Grid element.  */
      "className": _propTypes["default"].string,
      /** Number of columns in grid.  */
      "columnCount": _propTypes["default"].number.isRequired,
      /** Either a fixed column width (number) or a function that returns the width of a column given its index.  */
      "columnWidth": function columnWidth() {
        return (typeof _types.bpfrpt_proptype_CellSize === "function" ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes["default"].shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
      },
      /** Unfiltered props for the Grid container. */
      "containerProps": _propTypes["default"].object,
      /** ARIA role for the cell-container.  */
      "containerRole": _propTypes["default"].string.isRequired,
      /** Optional inline style applied to inner cell-container */
      "containerStyle": _propTypes["default"].object.isRequired,
      /**
       * If CellMeasurer is used to measure this Grid's children, this should be a pointer to its CellMeasurerCache.
       * A shared CellMeasurerCache reference enables Grid and CellMeasurer to share measurement data.
       */
      "deferredMeasurementCache": _propTypes["default"].object,
      /**
       * Used to estimate the total width of a Grid before all of its columns have actually been measured.
       * The estimated total width is adjusted as columns are rendered.
       */
      "estimatedColumnSize": _propTypes["default"].number.isRequired,
      /**
       * Used to estimate the total height of a Grid before all of its rows have actually been measured.
       * The estimated total height is adjusted as rows are rendered.
       */
      "estimatedRowSize": _propTypes["default"].number.isRequired,
      /** Exposed for testing purposes only.  */
      "getScrollbarSize": _propTypes["default"].func.isRequired,
      /** Height of Grid; this property determines the number of visible (vs virtualized) rows.  */
      "height": _propTypes["default"].number.isRequired,
      /** Optional custom id to attach to root Grid element.  */
      "id": _propTypes["default"].string,
      /**
       * Override internal is-scrolling state tracking.
       * This property is primarily intended for use with the WindowScroller component.
       */
      "isScrolling": _propTypes["default"].bool,
      /**
       * Opt-out of isScrolling param passed to cellRangeRenderer.
       * To avoid the extra render when scroll stops.
       */
      "isScrollingOptOut": _propTypes["default"].bool.isRequired,
      /** Optional renderer to be used in place of rows when either :rowCount or :columnCount is 0.  */
      "noContentRenderer": function noContentRenderer() {
        return (typeof _types.bpfrpt_proptype_NoContentRenderer === "function" ? _types.bpfrpt_proptype_NoContentRenderer.isRequired ? _types.bpfrpt_proptype_NoContentRenderer.isRequired : _types.bpfrpt_proptype_NoContentRenderer : _propTypes["default"].shape(_types.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);
      },
      /**
       * Callback invoked whenever the scroll offset changes within the inner scrollable region.
       * This callback can be used to sync scrolling between lists, tables, or grids.
       */
      "onScroll": _propTypes["default"].func.isRequired,
      /**
       * Called whenever a horizontal or vertical scrollbar is added or removed.
       * This prop is not intended for end-user use;
       * It is used by MultiGrid to support fixed-row/fixed-column scroll syncing.
       */
      "onScrollbarPresenceChange": _propTypes["default"].func.isRequired,
      /** Callback invoked with information about the section of the Grid that was just rendered.  */
      "onSectionRendered": _propTypes["default"].func.isRequired,
      /**
       * Number of columns to render before/after the visible section of the grid.
       * These columns can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.
       */
      "overscanColumnCount": _propTypes["default"].number.isRequired,
      /**
       * Calculates the number of cells to overscan before and after a specified range.
       * This function ensures that overscanning doesn't exceed the available cells.
       */
      "overscanIndicesGetter": function overscanIndicesGetter() {
        return (typeof _types.bpfrpt_proptype_OverscanIndicesGetter === "function" ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _types.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _types.bpfrpt_proptype_OverscanIndicesGetter : _propTypes["default"].shape(_types.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);
      },
      /**
       * Number of rows to render above/below the visible section of the grid.
       * These rows can help for smoother scrolling on touch devices or browsers that send scroll events infrequently.
       */
      "overscanRowCount": _propTypes["default"].number.isRequired,
      /** ARIA role for the grid element.  */
      "role": _propTypes["default"].string.isRequired,
      /**
       * Either a fixed row height (number) or a function that returns the height of a row given its index.
       * Should implement the following interface: ({ index: number }): number
       */
      "rowHeight": function rowHeight() {
        return (typeof _types.bpfrpt_proptype_CellSize === "function" ? _types.bpfrpt_proptype_CellSize.isRequired ? _types.bpfrpt_proptype_CellSize.isRequired : _types.bpfrpt_proptype_CellSize : _propTypes["default"].shape(_types.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
      },
      /** Number of rows in grid.  */
      "rowCount": _propTypes["default"].number.isRequired,
      /** Wait this amount of time after the last scroll event before resetting Grid `pointer-events`. */
      "scrollingResetTimeInterval": _propTypes["default"].number.isRequired,
      /** Horizontal offset. */
      "scrollLeft": _propTypes["default"].number,
      /**
       * Controls scroll-to-cell behavior of the Grid.
       * The default ("auto") scrolls the least amount possible to ensure that the specified cell is fully visible.
       * Use "start" to align cells to the top/left of the Grid and "end" to align bottom/right.
       */
      "scrollToAlignment": function scrollToAlignment() {
        return (typeof _types.bpfrpt_proptype_Alignment === "function" ? _types.bpfrpt_proptype_Alignment.isRequired ? _types.bpfrpt_proptype_Alignment.isRequired : _types.bpfrpt_proptype_Alignment : _propTypes["default"].shape(_types.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);
      },
      /** Column index to ensure visible (by forcefully scrolling if necessary) */
      "scrollToColumn": _propTypes["default"].number.isRequired,
      /** Vertical offset. */
      "scrollTop": _propTypes["default"].number,
      /** Row index to ensure visible (by forcefully scrolling if necessary) */
      "scrollToRow": _propTypes["default"].number.isRequired,
      /** Optional inline style */
      "style": _propTypes["default"].object.isRequired,
      /** Tab index for focus */
      "tabIndex": _propTypes["default"].number,
      /** Width of Grid; this property determines the number of visible (vs virtualized) columns.  */
      "width": _propTypes["default"].number.isRequired
    }), _temp);
    (0, _defineProperty2["default"])(Grid, "defaultProps", {
      "aria-label": "grid",
      "aria-readonly": true,
      autoContainerWidth: false,
      autoHeight: false,
      autoWidth: false,
      cellRangeRenderer: _defaultCellRangeRenderer["default"],
      containerRole: "rowgroup",
      containerStyle: {},
      estimatedColumnSize: 100,
      estimatedRowSize: 30,
      getScrollbarSize: _scrollbarSize["default"],
      noContentRenderer: renderNull,
      onScroll: function onScroll() {
      },
      onScrollbarPresenceChange: function onScrollbarPresenceChange() {
      },
      onSectionRendered: function onSectionRendered() {
      },
      overscanColumnCount: 0,
      overscanIndicesGetter: _defaultOverscanIndicesGetter["default"],
      overscanRowCount: 10,
      role: "grid",
      scrollingResetTimeInterval: DEFAULT_SCROLLING_RESET_TIME_INTERVAL,
      scrollToAlignment: "auto",
      scrollToColumn: -1,
      scrollToRow: -1,
      style: {},
      tabIndex: 0,
      isScrollingOptOut: false
    });
    (0, _reactLifecyclesCompat.polyfill)(Grid);
    var _default = Grid;
    exports["default"] = _default;
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/accessibilityOverscanIndicesGetter.js
var require_accessibilityOverscanIndicesGetter = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/accessibilityOverscanIndicesGetter.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = defaultOverscanIndicesGetter;
    exports.SCROLL_DIRECTION_VERTICAL = exports.SCROLL_DIRECTION_HORIZONTAL = exports.SCROLL_DIRECTION_FORWARD = exports.SCROLL_DIRECTION_BACKWARD = void 0;
    var _types = require_types();
    var SCROLL_DIRECTION_BACKWARD = -1;
    exports.SCROLL_DIRECTION_BACKWARD = SCROLL_DIRECTION_BACKWARD;
    var SCROLL_DIRECTION_FORWARD = 1;
    exports.SCROLL_DIRECTION_FORWARD = SCROLL_DIRECTION_FORWARD;
    var SCROLL_DIRECTION_HORIZONTAL = "horizontal";
    exports.SCROLL_DIRECTION_HORIZONTAL = SCROLL_DIRECTION_HORIZONTAL;
    var SCROLL_DIRECTION_VERTICAL = "vertical";
    exports.SCROLL_DIRECTION_VERTICAL = SCROLL_DIRECTION_VERTICAL;
    function defaultOverscanIndicesGetter(_ref) {
      var cellCount = _ref.cellCount, overscanCellsCount = _ref.overscanCellsCount, scrollDirection = _ref.scrollDirection, startIndex = _ref.startIndex, stopIndex = _ref.stopIndex;
      overscanCellsCount = Math.max(1, overscanCellsCount);
      if (scrollDirection === SCROLL_DIRECTION_FORWARD) {
        return {
          overscanStartIndex: Math.max(0, startIndex - 1),
          overscanStopIndex: Math.min(cellCount - 1, stopIndex + overscanCellsCount)
        };
      } else {
        return {
          overscanStartIndex: Math.max(0, startIndex - overscanCellsCount),
          overscanStopIndex: Math.min(cellCount - 1, stopIndex + 1)
        };
      }
    }
  }
});

// node_modules/react-virtualized/dist/commonjs/Grid/index.js
var require_Grid2 = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/Grid/index.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function get() {
        return _Grid["default"];
      }
    });
    Object.defineProperty(exports, "Grid", {
      enumerable: true,
      get: function get() {
        return _Grid["default"];
      }
    });
    Object.defineProperty(exports, "accessibilityOverscanIndicesGetter", {
      enumerable: true,
      get: function get() {
        return _accessibilityOverscanIndicesGetter["default"];
      }
    });
    Object.defineProperty(exports, "defaultCellRangeRenderer", {
      enumerable: true,
      get: function get() {
        return _defaultCellRangeRenderer["default"];
      }
    });
    Object.defineProperty(exports, "defaultOverscanIndicesGetter", {
      enumerable: true,
      get: function get() {
        return _defaultOverscanIndicesGetter["default"];
      }
    });
    Object.defineProperty(exports, "bpfrpt_proptype_NoContentRenderer", {
      enumerable: true,
      get: function get() {
        return _types.bpfrpt_proptype_NoContentRenderer;
      }
    });
    Object.defineProperty(exports, "bpfrpt_proptype_Alignment", {
      enumerable: true,
      get: function get() {
        return _types.bpfrpt_proptype_Alignment;
      }
    });
    Object.defineProperty(exports, "bpfrpt_proptype_CellPosition", {
      enumerable: true,
      get: function get() {
        return _types.bpfrpt_proptype_CellPosition;
      }
    });
    Object.defineProperty(exports, "bpfrpt_proptype_CellSize", {
      enumerable: true,
      get: function get() {
        return _types.bpfrpt_proptype_CellSize;
      }
    });
    Object.defineProperty(exports, "bpfrpt_proptype_OverscanIndicesGetter", {
      enumerable: true,
      get: function get() {
        return _types.bpfrpt_proptype_OverscanIndicesGetter;
      }
    });
    Object.defineProperty(exports, "bpfrpt_proptype_RenderedSection", {
      enumerable: true,
      get: function get() {
        return _types.bpfrpt_proptype_RenderedSection;
      }
    });
    Object.defineProperty(exports, "bpfrpt_proptype_CellRendererParams", {
      enumerable: true,
      get: function get() {
        return _types.bpfrpt_proptype_CellRendererParams;
      }
    });
    Object.defineProperty(exports, "bpfrpt_proptype_Scroll", {
      enumerable: true,
      get: function get() {
        return _types.bpfrpt_proptype_Scroll;
      }
    });
    var _Grid = _interopRequireDefault(require_Grid());
    var _accessibilityOverscanIndicesGetter = _interopRequireDefault(require_accessibilityOverscanIndicesGetter());
    var _defaultCellRangeRenderer = _interopRequireDefault(require_defaultCellRangeRenderer());
    var _defaultOverscanIndicesGetter = _interopRequireDefault(require_defaultOverscanIndicesGetter());
    var _types = require_types();
  }
});

// node_modules/react-virtualized/dist/commonjs/List/types.js
var require_types2 = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/List/types.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.bpfrpt_proptype_Scroll = exports.bpfrpt_proptype_RenderedRows = exports.bpfrpt_proptype_RowRenderer = exports.bpfrpt_proptype_RowRendererParams = void 0;
    var React = _interopRequireWildcard(require_react());
    var _propTypes = _interopRequireDefault(require_prop_types());
    var bpfrpt_proptype_RowRendererParams = false ? null : {
      "index": _propTypes["default"].number.isRequired,
      "isScrolling": _propTypes["default"].bool.isRequired,
      "isVisible": _propTypes["default"].bool.isRequired,
      "key": _propTypes["default"].string.isRequired,
      "parent": _propTypes["default"].object.isRequired,
      "style": _propTypes["default"].object.isRequired
    };
    exports.bpfrpt_proptype_RowRendererParams = bpfrpt_proptype_RowRendererParams;
    var bpfrpt_proptype_RowRenderer = false ? null : _propTypes["default"].func;
    exports.bpfrpt_proptype_RowRenderer = bpfrpt_proptype_RowRenderer;
    var bpfrpt_proptype_RenderedRows = false ? null : {
      "overscanStartIndex": _propTypes["default"].number.isRequired,
      "overscanStopIndex": _propTypes["default"].number.isRequired,
      "startIndex": _propTypes["default"].number.isRequired,
      "stopIndex": _propTypes["default"].number.isRequired
    };
    exports.bpfrpt_proptype_RenderedRows = bpfrpt_proptype_RenderedRows;
    var bpfrpt_proptype_Scroll = false ? null : {
      "clientHeight": _propTypes["default"].number.isRequired,
      "scrollHeight": _propTypes["default"].number.isRequired,
      "scrollTop": _propTypes["default"].number.isRequired
    };
    exports.bpfrpt_proptype_Scroll = bpfrpt_proptype_Scroll;
  }
});

// node_modules/react-virtualized/dist/commonjs/List/List.js
var require_List = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/List/List.js"(exports) {
    "use strict";
    var _interopRequireDefault = require_interopRequireDefault();
    var _interopRequireWildcard = require_interopRequireWildcard();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports["default"] = void 0;
    var _extends2 = _interopRequireDefault(require_extends());
    var _classCallCheck2 = _interopRequireDefault(require_classCallCheck());
    var _createClass2 = _interopRequireDefault(require_createClass());
    var _possibleConstructorReturn2 = _interopRequireDefault(require_possibleConstructorReturn());
    var _getPrototypeOf3 = _interopRequireDefault(require_getPrototypeOf());
    var _assertThisInitialized2 = _interopRequireDefault(require_assertThisInitialized());
    var _inherits2 = _interopRequireDefault(require_inherits());
    var _defineProperty2 = _interopRequireDefault(require_defineProperty());
    var _Grid = _interopRequireWildcard(require_Grid2());
    var React = _interopRequireWildcard(require_react());
    var _clsx = _interopRequireDefault((init_clsx_m(), __toCommonJS(clsx_m_exports)));
    var _types = require_types2();
    var _propTypes = _interopRequireDefault(require_prop_types());
    var _class;
    var _temp;
    var List = (_temp = _class = function(_React$PureComponent) {
      (0, _inherits2["default"])(List2, _React$PureComponent);
      function List2() {
        var _getPrototypeOf2;
        var _this;
        (0, _classCallCheck2["default"])(this, List2);
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        _this = (0, _possibleConstructorReturn2["default"])(this, (_getPrototypeOf2 = (0, _getPrototypeOf3["default"])(List2)).call.apply(_getPrototypeOf2, [this].concat(args)));
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "Grid", void 0);
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_cellRenderer", function(_ref) {
          var parent = _ref.parent, rowIndex = _ref.rowIndex, style = _ref.style, isScrolling = _ref.isScrolling, isVisible = _ref.isVisible, key = _ref.key;
          var rowRenderer = _this.props.rowRenderer;
          var widthDescriptor = Object.getOwnPropertyDescriptor(style, "width");
          if (widthDescriptor && widthDescriptor.writable) {
            style.width = "100%";
          }
          return rowRenderer({
            index: rowIndex,
            style,
            isScrolling,
            isVisible,
            key,
            parent
          });
        });
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_setRef", function(ref) {
          _this.Grid = ref;
        });
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onScroll", function(_ref2) {
          var clientHeight = _ref2.clientHeight, scrollHeight = _ref2.scrollHeight, scrollTop = _ref2.scrollTop;
          var onScroll = _this.props.onScroll;
          onScroll({
            clientHeight,
            scrollHeight,
            scrollTop
          });
        });
        (0, _defineProperty2["default"])((0, _assertThisInitialized2["default"])(_this), "_onSectionRendered", function(_ref3) {
          var rowOverscanStartIndex = _ref3.rowOverscanStartIndex, rowOverscanStopIndex = _ref3.rowOverscanStopIndex, rowStartIndex = _ref3.rowStartIndex, rowStopIndex = _ref3.rowStopIndex;
          var onRowsRendered = _this.props.onRowsRendered;
          onRowsRendered({
            overscanStartIndex: rowOverscanStartIndex,
            overscanStopIndex: rowOverscanStopIndex,
            startIndex: rowStartIndex,
            stopIndex: rowStopIndex
          });
        });
        return _this;
      }
      (0, _createClass2["default"])(List2, [{
        key: "forceUpdateGrid",
        value: function forceUpdateGrid() {
          if (this.Grid) {
            this.Grid.forceUpdate();
          }
        }
        /** See Grid#getOffsetForCell */
      }, {
        key: "getOffsetForRow",
        value: function getOffsetForRow(_ref4) {
          var alignment = _ref4.alignment, index = _ref4.index;
          if (this.Grid) {
            var _this$Grid$getOffsetF = this.Grid.getOffsetForCell({
              alignment,
              rowIndex: index,
              columnIndex: 0
            }), scrollTop = _this$Grid$getOffsetF.scrollTop;
            return scrollTop;
          }
          return 0;
        }
        /** CellMeasurer compatibility */
      }, {
        key: "invalidateCellSizeAfterRender",
        value: function invalidateCellSizeAfterRender(_ref5) {
          var columnIndex = _ref5.columnIndex, rowIndex = _ref5.rowIndex;
          if (this.Grid) {
            this.Grid.invalidateCellSizeAfterRender({
              rowIndex,
              columnIndex
            });
          }
        }
        /** See Grid#measureAllCells */
      }, {
        key: "measureAllRows",
        value: function measureAllRows() {
          if (this.Grid) {
            this.Grid.measureAllCells();
          }
        }
        /** CellMeasurer compatibility */
      }, {
        key: "recomputeGridSize",
        value: function recomputeGridSize() {
          var _ref6 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, _ref6$columnIndex = _ref6.columnIndex, columnIndex = _ref6$columnIndex === void 0 ? 0 : _ref6$columnIndex, _ref6$rowIndex = _ref6.rowIndex, rowIndex = _ref6$rowIndex === void 0 ? 0 : _ref6$rowIndex;
          if (this.Grid) {
            this.Grid.recomputeGridSize({
              rowIndex,
              columnIndex
            });
          }
        }
        /** See Grid#recomputeGridSize */
      }, {
        key: "recomputeRowHeights",
        value: function recomputeRowHeights() {
          var index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (this.Grid) {
            this.Grid.recomputeGridSize({
              rowIndex: index,
              columnIndex: 0
            });
          }
        }
        /** See Grid#scrollToPosition */
      }, {
        key: "scrollToPosition",
        value: function scrollToPosition() {
          var scrollTop = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (this.Grid) {
            this.Grid.scrollToPosition({
              scrollTop
            });
          }
        }
        /** See Grid#scrollToCell */
      }, {
        key: "scrollToRow",
        value: function scrollToRow() {
          var index = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : 0;
          if (this.Grid) {
            this.Grid.scrollToCell({
              columnIndex: 0,
              rowIndex: index
            });
          }
        }
      }, {
        key: "render",
        value: function render() {
          var _this$props = this.props, className = _this$props.className, noRowsRenderer = _this$props.noRowsRenderer, scrollToIndex = _this$props.scrollToIndex, width = _this$props.width;
          var classNames = (0, _clsx["default"])("ReactVirtualized__List", className);
          return React.createElement(_Grid["default"], (0, _extends2["default"])({}, this.props, {
            autoContainerWidth: true,
            cellRenderer: this._cellRenderer,
            className: classNames,
            columnWidth: width,
            columnCount: 1,
            noContentRenderer: noRowsRenderer,
            onScroll: this._onScroll,
            onSectionRendered: this._onSectionRendered,
            ref: this._setRef,
            scrollToRow: scrollToIndex
          }));
        }
      }]);
      return List2;
    }(React.PureComponent), (0, _defineProperty2["default"])(_class, "propTypes", false ? null : {
      "aria-label": _propTypes["default"].string,
      /**
       * Removes fixed height from the scrollingContainer so that the total height
       * of rows can stretch the window. Intended for use with WindowScroller
       */
      "autoHeight": _propTypes["default"].bool.isRequired,
      /** Optional CSS class name */
      "className": _propTypes["default"].string,
      /**
       * Used to estimate the total height of a List before all of its rows have actually been measured.
       * The estimated total height is adjusted as rows are rendered.
       */
      "estimatedRowSize": _propTypes["default"].number.isRequired,
      /** Height constraint for list (determines how many actual rows are rendered) */
      "height": _propTypes["default"].number.isRequired,
      /** Optional renderer to be used in place of rows when rowCount is 0 */
      "noRowsRenderer": function noRowsRenderer() {
        return (typeof _Grid.bpfrpt_proptype_NoContentRenderer === "function" ? _Grid.bpfrpt_proptype_NoContentRenderer.isRequired ? _Grid.bpfrpt_proptype_NoContentRenderer.isRequired : _Grid.bpfrpt_proptype_NoContentRenderer : _propTypes["default"].shape(_Grid.bpfrpt_proptype_NoContentRenderer).isRequired).apply(this, arguments);
      },
      /** Callback invoked with information about the slice of rows that were just rendered.  */
      "onRowsRendered": _propTypes["default"].func.isRequired,
      /**
       * Callback invoked whenever the scroll offset changes within the inner scrollable region.
       * This callback can be used to sync scrolling between lists, tables, or grids.
       */
      "onScroll": _propTypes["default"].func.isRequired,
      /** See Grid#overscanIndicesGetter */
      "overscanIndicesGetter": function overscanIndicesGetter() {
        return (typeof _Grid.bpfrpt_proptype_OverscanIndicesGetter === "function" ? _Grid.bpfrpt_proptype_OverscanIndicesGetter.isRequired ? _Grid.bpfrpt_proptype_OverscanIndicesGetter.isRequired : _Grid.bpfrpt_proptype_OverscanIndicesGetter : _propTypes["default"].shape(_Grid.bpfrpt_proptype_OverscanIndicesGetter).isRequired).apply(this, arguments);
      },
      /**
       * Number of rows to render above/below the visible bounds of the list.
       * These rows can help for smoother scrolling on touch devices.
       */
      "overscanRowCount": _propTypes["default"].number.isRequired,
      /** Either a fixed row height (number) or a function that returns the height of a row given its index.  */
      "rowHeight": function rowHeight() {
        return (typeof _Grid.bpfrpt_proptype_CellSize === "function" ? _Grid.bpfrpt_proptype_CellSize.isRequired ? _Grid.bpfrpt_proptype_CellSize.isRequired : _Grid.bpfrpt_proptype_CellSize : _propTypes["default"].shape(_Grid.bpfrpt_proptype_CellSize).isRequired).apply(this, arguments);
      },
      /** Responsible for rendering a row given an index; ({ index: number }): node */
      "rowRenderer": function rowRenderer() {
        return (typeof _types.bpfrpt_proptype_RowRenderer === "function" ? _types.bpfrpt_proptype_RowRenderer.isRequired ? _types.bpfrpt_proptype_RowRenderer.isRequired : _types.bpfrpt_proptype_RowRenderer : _propTypes["default"].shape(_types.bpfrpt_proptype_RowRenderer).isRequired).apply(this, arguments);
      },
      /** Number of rows in list. */
      "rowCount": _propTypes["default"].number.isRequired,
      /** See Grid#scrollToAlignment */
      "scrollToAlignment": function scrollToAlignment() {
        return (typeof _Grid.bpfrpt_proptype_Alignment === "function" ? _Grid.bpfrpt_proptype_Alignment.isRequired ? _Grid.bpfrpt_proptype_Alignment.isRequired : _Grid.bpfrpt_proptype_Alignment : _propTypes["default"].shape(_Grid.bpfrpt_proptype_Alignment).isRequired).apply(this, arguments);
      },
      /** Row index to ensure visible (by forcefully scrolling if necessary) */
      "scrollToIndex": _propTypes["default"].number.isRequired,
      /** Vertical offset. */
      "scrollTop": _propTypes["default"].number,
      /** Optional inline style */
      "style": _propTypes["default"].object.isRequired,
      /** Tab index for focus */
      "tabIndex": _propTypes["default"].number,
      /** Width of list */
      "width": _propTypes["default"].number.isRequired
    }), _temp);
    exports["default"] = List;
    (0, _defineProperty2["default"])(List, "defaultProps", {
      autoHeight: false,
      estimatedRowSize: 30,
      onScroll: function onScroll() {
      },
      noRowsRenderer: function noRowsRenderer() {
        return null;
      },
      onRowsRendered: function onRowsRendered() {
      },
      overscanIndicesGetter: _Grid.accessibilityOverscanIndicesGetter,
      overscanRowCount: 10,
      scrollToAlignment: "auto",
      scrollToIndex: -1,
      style: {}
    });
  }
});

// node_modules/react-virtualized/dist/commonjs/List/index.js
var require_List2 = __commonJS({
  "node_modules/react-virtualized/dist/commonjs/List/index.js"(exports) {
    var _interopRequireDefault = require_interopRequireDefault();
    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    Object.defineProperty(exports, "default", {
      enumerable: true,
      get: function get() {
        return _List["default"];
      }
    });
    Object.defineProperty(exports, "List", {
      enumerable: true,
      get: function get() {
        return _List["default"];
      }
    });
    Object.defineProperty(exports, "bpfrpt_proptype_RowRendererParams", {
      enumerable: true,
      get: function get() {
        return _types.bpfrpt_proptype_RowRendererParams;
      }
    });
    var _List = _interopRequireDefault(require_List());
    var _types = require_types2();
  }
});
export default require_List2();
//# sourceMappingURL=react-virtualized_dist_commonjs_List.js.map
